
{
    
    
    
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
    "pages": [{"date":"2022-11-05","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/concurrency-pattern-generator-future/","summary":"Generator Pattern allows the consumer of the data produced by the generator to run in parallel when the generator function is busy computing the next value.\nA Future indicates any data that is needed in future but its computation can be started in parallel so that it can be fetched from the background when needed.","tags":["concurrency pattern","golang"],"text":"generator pattern allows the consumer of the data produced by the generator to run in parallel when the generator function is busy computing the next value.\na future indicates any data that is needed in future but its computation can be started in parallel so that it can be fetched from the background when needed.\ngenerator generator pattern is used to generator a sequence of values which is used to produce some output. this allows the consumer of the data produced by the generator to run in parallel when the generator function is busy computing the text value.\nfunc fib(n int) chan int { c := make(chan int) go func() { // next state is depend on previous state for i, j := 0, 1; i \u0026lt; n; i, j = i+j, i { c \u0026lt;- i } close(c) }() return c } func consumer(c chan int) { for v := range c { fmt.println(v) } } the generator and the consumer can work concurrently (maybe in parallel) as the logic involved in both are different.\nfuture a future indicates any data that is needed in future but its computation can be started in parallel so that it can be fetched from the background when needed. mostly, futures are used to send asynchronous http request.\ntype data struct { body []byte error error } func futuredate(url string) \u0026lt;- chan data { c := make(chan data, 1) go func(){ resp, err := http.get(url) if err != nil { c \u0026lt;- data{ body: nil, error: err, } return } body, err := ioutil.readall(resp.body) resp.body.close() if err != nil { c \u0026lt;- data{ body: nil, error: err, } return } c \u0026lt;- data{ body: body, error: err, } }() return nil } the actual http request is done asynchronously in a goroutine. the main function can continue doing other things. when the result is needed, we read the result from the channel. if the request isn\u0026rsquo;t finished yet, the channel will block until the result is ready.\ndifferent between generator and future in generator pattern, we generate next state base on previous state (maybe not), but i purpose is compute many things in background. in future pattern, we use goroutine to execute an \u0026ldquo;heavy job\u0026rdquo; (only one job).\n","title":"Generator and Future Pattern"},{"date":"2022-11-03","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/concurrency-pattern-fan-in-fan-out/","summary":"You\u0026rsquo;ve got a pipeline set up. Data is flowing through your system beautifully. Sometimes, stages in your pipeline can be computationally expensive. When this happens, upstream stages in your pipeline can become blocked while waiting for your expensive stages to complete.","tags":["concurrency pattern","golang"],"text":"you\u0026rsquo;ve got a pipeline set up. data is flowing through your system beautifully. sometimes, stages in your pipeline can be computationally expensive. when this happens, upstream stages in your pipeline can become blocked while waiting for your expensive stages to complete.\none of the interesting properties of pipelines is the ability they give you to operate on the stream of data using a combination of separate, often reordered stages. maybe that would help improve the performance of the pipeline. in fact, it turns out it can, and this pattern has a name: fan-out, fan-in.\na generator function generator (aka iterator) pattern is used to generate a sequence of values which is used to produce some output. this allows the consumer of the data producer by the generator to run in parallel when the generator function is busy computing the next value.\nfunc generator(data string) \u0026lt;- chan string { channel := make(chan string) go func(){ for { channel \u0026lt;- data time.sleep(time.duration(100*time.millisecond)) } }() return channel } fan out fan-out is a term to describe the process of starting multiple goroutines to handle input from the pipeline.\nyou might consider fanning out one of your stages if both of the following apply:\nit doesn\u0026rsquo;t rely on values that the state had calculated before. it takes a long time to run. (system call, a heavy cpu job, \u0026hellip;) the property of order-independence is important because you have no guarantee in what order concurrent copies of your stage will run, nor in what order they will return.\nfan in fan-in is a term to describe the process of combining multiple results into one channel.\n","title":"Fan out, Fan in"},{"date":"2022-10-13","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/poem-hai-%C4%91%E1%BB%A9a-tr%E1%BA%BB/","summary":"Hai đứa trẻ lớn lên nơi rừng núi\nXung quanh nhà nào là cỏ, là cây\nHai đứa trẻ là chị là em, và là bạn\nBạn bè xung quanh, hiếm lắm ấy mà.\nHai đứa trẻ nhiều đêm khó ngủ","tags":["thơ"],"text":"hai đứa trẻ lớn lên nơi rừng núi\nxung quanh nhà nào là cỏ, là cây\nhai đứa trẻ là chị là em, và là bạn\nbạn bè xung quanh, hiếm lắm ấy mà.\nhai đứa trẻ nhiều đêm khó ngủ\nbố mẹ đi rẫy mãi chưa về\nhai đứa trẻ ngồi bên ngọn nến sáng\nchỉ bóng trên tường, gọi mẹ xưng con.\nhai đứa trẻ rời xa nơi nương náu\nbố mẹ lo chuyện học hành mai sau\nhai đứa trẻ là chị là em, không là bạn\nnhảy dây, bị mắt, thú vị hơn nhiều.\nhai đứa trẻ mai này rồi cũng lớn\nđứa rời xóm làng, đứa tìm thủ đô\nhai đứa trẻ hiếm nào khi hỏi chuyện\nchuyện học hành, chuyện tương lai, chuyện mai sau\nhai đứa trẻ, hai đứa trẻ ấy không còn\u0026hellip;\n","title":"Hai Đứa Trẻ"},{"date":"2022-03-11","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/poem-m%C6%B0a/","summary":"Mưa,\nMưa trên mái hiên nhà\nĐến tận cánh đồng xa\nMưa,\nMưa hoài, mưa xối xả\nKìa ai đang thả thuyền lá\nKí ức trôi\nTrôi mãi tận miền xa.","tags":["thơ"],"text":"mưa,\nmưa trên mái hiên nhà\nđến tận cánh đồng xa\nmưa,\nmưa hoài, mưa xối xả\nkìa ai đang thả thuyền lá\nkí ức trôi\ntrôi mãi tận miền xa.\n","title":"Mưa"},{"date":"2021-10-20","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/poem-l%E1%BB%ADa-h%E1%BB%93ng/","summary":"Có một đốm than nhỏ\nThắp lên ngọn lửa hồng\nDành trọn nhiệt huyết nồng\nTháp sáng ước mơ to.","tags":["thơ"],"text":"có một đốm than nhỏ\nthắp lên ngọn lửa hồng\ndành trọn nhiệt huyết nồng\ntháp sáng ước mơ to.\n","title":"Lửa Hồng"},{"date":"0001-01-01","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/tech-talk-concurrent-is-not-parallelism/","summary":"","tags":[],"text":"","title":""},{"date":"0001-01-01","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/tech-talk-reactive-programming-by-vertx/","summary":"","tags":[],"text":"","title":""}]
}

