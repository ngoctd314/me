
{
    
    
    
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
    "pages": [{"date":"2022-11-08","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/linux-auto-connect-openvpn/","summary":"The OpenVPN is an open source Virtual Private Network (VPN) project. It creates secure connections over the Internet using a custom security protocol that utilizes SSL/TLS.\nIn this article, i will introduce naive solution for automatic connect to VPN using openvpn and systemd management.","tags":["linux"],"text":"the openvpn is an open source virtual private network (vpn) project. it creates secure connections over the internet using a custom security protocol that utilizes ssl/tls.\nin this article, i will introduce naive solution for automatic connect to vpn using openvpn and systemd management.\ncreate vpn script\n# create script connect to vpn mkdir -p ~/scripts cd ~/scripts touch vpn.sh sudo chmod +x vpn.sh ~/scripts/vpn.sh\nvpn_user=\u0026#34;\u0026#34; # insert vpn user here vpn_password=\u0026#34;\u0026#34; # insert vpn password here otp_key=\u0026#34;\u0026#34; # insert otp key here ovpn_file=\u0026#34;\u0026#34; # insert path to .ovpn file here. example /home/admicro-bigdata.ovpn vpn_auth=\u0026#34;$(oathtool -b --totp $otp_key)$vpn_password\u0026#34; echo $vpn_password | sudo -s bash -c \u0026#34;openvpn --config $ovpn_file --auth-user-pass \u0026lt;(echo -e \u0026#39;$vpn_user\\n$vpn_auth\u0026#39;) --daemon\u0026#34; create systemd service\ncd /lib/systemd/system sudo touch vpn.service /lib/systemd/system/vpn.service\n[unit] description=auto connect vccorp\u0026#39;s vpn service. [service] type=forking user=root execstart=~/scripts/vpn.sh execreload=~/script/vpn.sh execstop=sudo killall openvpn restart=on-failure restartsec=1s [install] wantedby=multi-user.target start,stop,auto restart service\nsudo systemctl enable vpn # auto start when vpn was killed sudo systemctl start vpn # start vpn sudo systemctl status vpn # check vpn status sudo systemctl stop vpn # stop vpn ","title":"Automatic connect to VPN"},{"date":"2022-11-05","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/programming-language-channel-in-golang/","summary":"Channel is an important built-in feature in Go. It is one of the features makes Go unique. Channel makes concurrent programming convenient, fun and lowers the difficulties of concurrent programming. Channel mainly acts as a concurrency synchronization technique. To understand channels better, the internal structure of channels and some implementation details by the standard Go compiler/runtime are also simply described.","tags":["basic","golang"],"text":"channel is an important built-in feature in go. it is one of the features makes go unique. channel makes concurrent programming convenient, fun and lowers the difficulties of concurrent programming. channel mainly acts as a concurrency synchronization technique. to understand channels better, the internal structure of channels and some implementation details by the standard go compiler/runtime are also simply described.\nchannel introduction don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\ncommunicating by sharing memory and sharing by communicating are two programming manners in concurrent programming. when goroutines communicate by sharing memory, we use traditional concurrency sychronization techniques, such as mutex locks, to protect the shared memory to prevent data racts.\ngo also provides another concurrency sychronization technique, channel. channels make goroutines share memory by communicating. we can view a channel as an internal fifo queu within a program. some goroutines send values to the queue (the channel) and some other goroutines receive values from the queue.\nalong with transfering values (through channels), the ownership of some values may also be transferred between goroutines (ownership on logic view). when a goroutine send a value to a channel, we can view the goroutine releases the ownership of some values. when a goroutine receives a value from a channel, we can view the goroutine acquires the ownerships of some values.\nchannel value comparisons all channel types are comparable types. if one channel value is assigned to another, the two channels share the same underlying part(s). in other words, those two channels represent the same internal channel object. the result of comparing them is true.\ndetailed explanations for channel operations operation a nil channel a closed channel a not-closed non-nil channel close panic panic success send value to block for ever panic block or succeed to send receive value from block for ever never block block or success to receive to bettern understand channel types and values, and to make some explainations easier, looking in the raw internal structures of internal channel objects is very helpful.\nwe can think of each channel consistin of three queues internally:\nthe receiving goroutine queue (generally fifo). the queue is a linked list without size limitation. goroutines in this queue are all in blocking state and waiting to receive values from that channel.\nthe sending goroutine queue (generally fifo). the queue is also a linked list without size limitation. goroutines in this queue are all in blocking state and waiting to send values to that channel.\nthe value buffer queue (absolutely fifo). this is a circular queue. its size is equal to the capacity of the channel. if the current number of values stored in the value buffer queue of the channel reaches the capacity of the channel, the channel is called in full status. if no values are store in the value buffer queue of the channel currently, the channel is called in empty status. for a zero-capacity (unbuffered) channel is also in both full and empty status.\neach channel internally holds a mutex lock which is used to avoid data races in all kinds of operations\nchannel operation: try to receive when a goroutine r tries to receive a value from a not-closed non-nil channel, the goroutine r will acquire the lock associated with the channel firstly, the do the following steps until one condition is satisfied.\ncheck buffer, if the value buffer queue of the channel is not empty. the receiving goroutine queue of the channel must be empty ( buffer != empty =\u0026gt; receiveing queue == emtpy ). the goroutine r will receive (by unshifting) a value from the value buffer queue. if the sending goroutine queue of the channel is also not empty, a sending goroutine will be unshifted out of the sending goroutine queue and resumed to running state again. the value the just unshifted sending goroutine trying to send will be pushed into the value buffer queue of the channel. the receiving goroutine r continues running. for this scenario, the channel receive operation is called a non-blocking operation. the goroutine r will receive a value from the value buffer queue. the goroutine r will recceive a value from the value buffer queue. sending goroutine is not empty. goroutine s send value to buffer and enter running state again. -\u0026gt; the receiving goroutine r continues running. the channel receive operation is called a non-blocking operation\ncheck buffer, the value buffer of the channel is empty. if the sending goroutine queue of the channel is not empty, in which case the channel must be an unbuffered channel, the receiving goroutine r will unshift value from a send goroutine. the just unshifted sending goroutine will get unblocked and resumed to running state again. -\u0026gt; the receiving goroutine r continues running. the channel receive operation is called a non-blocking operation\nif value buffer queue and the sending goroutine queue of the channel are both emtpy, the goroutine r will be pushed into the receiving goroutine queue of the channel and enter (and stay in) blocking state. it may be resumed to running state when another goroutine sends a value to the channel later. -\u0026gt; the receiving goroutine r enter blocking state. the channel receive operation is called a blocking operation\nchannel operation: try to send when a goroutine s tries to send a value to a not-closed non-nil channel, the goroutine s will acquire the lock associated with the channel firstly, then do the following steps until one step condition is satisfied.\ncheck receiving goroutine queue. if the receiving goroutine queue of the channel is not empty, in which case the value buffer queue of the channel must be empty, the sending goroutine s will unshift a receiving goroutine from the receiving goroutine queue of the channel and send the value to the just unshifted receiving goroutine. the just unshifted receiving goroutine will get unblocked and resumed to running state again. -\u0026gt; the sending goroutine s continues running. the channel send operation is called a non-blocking operation\ncheck receiving goroutine queue (empty), check buffer queue ( not full ), in which case the sending goroutine queue must be also empty, the value the sending goroutine s trying to send will be pushed into the value buffer queue. -\u0026gt; the sending goroutine s continues running. the channel send operation is called a non-blocking operation\ncheck receiving goroutine queue (empty), check buffer queue ( full ), the sending goroutine s will be pushed into the sending goroutine queue of the channel and enter (and stay in) blocking state. it may be resumed to running state when another goroutine receives a value from the channel later. -\u0026gt; the sending goroutine s enter blocking. the channel send operation is called a blocking operation\nonce a non-nil channel is closed, sending a value to the channel will produce a runtime panic in the current goroutine. note sending data to a closed channel is viewed as a non-blocking operation.\nchannel operation: try to close when a goroutine tries to close a not-closed non-nil channel, once the goroutine has acquired the lock of the channel, both of the following two steps will be performed by the following order.\nif the receiving goroutine queue of the channel is not empty, in which case the value buffer of the channel must be empty, all the goroutines in the receiving goroutine queue of the channel will be unshifted one by one, each of themm will receive a zero value of the elemenet type of the channel and be resumed to running state. if the sending goroutine queue of the channel is not empty, all the goroutines in the sending goroutine queue of the channel will be unshifted one by one and each of them will produce a panic for sending on a closed channel. this is the reason why we should avoid concurrent send and close operations on the same channel. after a channel is closed, the values which have been already pushed into the value buffer of the channel are still there.\nafter a non-nil channel is closed, channel receive operations os the channel will never block\nsome facts about the internal queues of a channel if the channel is closed, both its sending and receiving goroutine queue must be empty, but its value buffer may not be empty. at any time, if the value buffer is not empty, then its receiving goroutine queue must be empty. at any time, if the value buffer is not full, then its sending goroutine queue must be empty. if the channel is buffered, then at time, at least one of the channel\u0026rsquo;s goroutine queues must be empty (sending, receiving or both). if the channel is unbuffered, most of the time one of its sending goroutine queue and the receiving goroutine queue must be empty, with one exception. the exception is that a goroutine may be pushed into both of the two queues when execution a select control flow code block. references channel use case go101\n","title":"Channel in Golang"},{"date":"2022-11-05","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/concurrency-pattern-fan-in-fan-out/","summary":"Fan-in Fan-out is a way of Multiplexing and De-Multiplexing in golang. Fan-in refers to processing multiple input data and combining into a single entity. Fan-out is the exact opposite, dividing the data into multiple smaller chunks,\nYou\u0026rsquo;ve got a pipeline set up.","tags":["concurrency pattern","golang"],"text":"fan-in fan-out is a way of multiplexing and de-multiplexing in golang. fan-in refers to processing multiple input data and combining into a single entity. fan-out is the exact opposite, dividing the data into multiple smaller chunks,\nyou\u0026rsquo;ve got a pipeline set up. data is flowing through your system beautifully. sometimes, stages in your pipeline can be computationally expensive. when this happens, upstream stages in your pipeline can become blocked while waiting for your expensive stages to complete.\none of the interesting properties of pipelines is the ability they give you to operate on the stream of data using a combination of separate, often reordered stages. maybe that would help improve the performance of the pipeline. in fact, it turns out it can, and this pattern has a name: fan-out, fan-in.\nfan out fan-out is a term to describe the process of starting multiple goroutines to handle input from the pipeline.\nyou might consider fanning out one of your stages if both of the following apply:\nit doesn\u0026rsquo;t rely on values that the state had calculated before. it takes a long time to run. (system call, a heavy cpu job, \u0026hellip;) the property of order-independence is important because you have no guarantee in what order concurrent copies of your stage will run, nor in what order they will return.\nfan in fan-in is a term to describe the process of combining multiple results into one channel.\n","title":"Fan out, Fan in"},{"date":"2022-11-05","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/concurrency-pattern-generator-future/","summary":"Generator Pattern allows the consumer of the data produced by the generator to run in parallel when the generator function is busy computing the next value.\nA Future indicates any data that is needed in future but its computation can be started in parallel so that it can be fetched from the background when needed.","tags":["concurrency pattern","golang"],"text":"generator pattern allows the consumer of the data produced by the generator to run in parallel when the generator function is busy computing the next value.\na future indicates any data that is needed in future but its computation can be started in parallel so that it can be fetched from the background when needed.\ngenerator generator pattern is used to generator a sequence of values which is used to produce some output. this allows the consumer of the data produced by the generator to run in parallel when the generator function is busy computing the text value.\nfunc fib(n int) chan int { c := make(chan int) go func() { // next state is depend on previous state for i, j := 0, 1; i \u0026lt; n; i, j = i+j, i { c \u0026lt;- i } close(c) }() return c } func consumer(c chan int) { for v := range c { fmt.println(v) } } the generator and the consumer can work concurrently (maybe in parallel) as the logic involved in both are different.\nfuture a future indicates any data that is needed in future but its computation can be started in parallel so that it can be fetched from the background when needed. mostly, futures are used to send asynchronous http request.\ntype data struct { body []byte error error } func futuredate(url string) \u0026lt;- chan data { c := make(chan data, 1) go func(){ resp, err := http.get(url) if err != nil { c \u0026lt;- data{ body: nil, error: err, } return } body, err := ioutil.readall(resp.body) resp.body.close() if err != nil { c \u0026lt;- data{ body: nil, error: err, } return } c \u0026lt;- data{ body: body, error: err, } }() return nil } the actual http request is done asynchronously in a goroutine. the main function can continue doing other things. when the result is needed, we read the result from the channel. if the request isn\u0026rsquo;t finished yet, the channel will block until the result is ready.\ndifferent between generator and future in generator pattern, we generate next state base on previous state (maybe not), but i purpose is compute many things in background. in future pattern, we use goroutine to execute an \u0026ldquo;heavy job\u0026rdquo; (only one job).\n","title":"Generator and Future Pattern"},{"date":"2022-10-13","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/poem-hai-%C4%91%E1%BB%A9a-tr%E1%BA%BB/","summary":"Hai đứa trẻ lớn lên nơi rừng núi\nXung quanh nhà nào là cỏ, là cây\nHai đứa trẻ là chị là em, và là bạn\nBạn bè xung quanh, hiếm lắm ấy mà.\nHai đứa trẻ nhiều đêm khó ngủ","tags":["thơ"],"text":"hai đứa trẻ lớn lên nơi rừng núi\nxung quanh nhà nào là cỏ, là cây\nhai đứa trẻ là chị là em, và là bạn\nbạn bè xung quanh, hiếm lắm ấy mà.\nhai đứa trẻ nhiều đêm khó ngủ\nbố mẹ đi rẫy mãi chưa về\nhai đứa trẻ ngồi bên ngọn nến sáng\nchỉ bóng trên tường, gọi mẹ xưng con.\nhai đứa trẻ rời xa nơi nương náu\nbố mẹ lo chuyện học hành mai sau\nhai đứa trẻ là chị là em, không là bạn\nnhảy dây, bị mắt, thú vị hơn nhiều.\nhai đứa trẻ mai này rồi cũng lớn\nđứa rời xóm làng, đứa tìm thủ đô\nhai đứa trẻ hiếm nào khi hỏi chuyện\nchuyện học hành, chuyện tương lai, chuyện mai sau\nhai đứa trẻ, hai đứa trẻ ấy không còn\u0026hellip;\n","title":"Hai Đứa Trẻ"},{"date":"2022-03-11","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/poem-m%C6%B0a/","summary":"Mưa,\nMưa trên mái hiên nhà\nĐến tận cánh đồng xa\nMưa,\nMưa hoài, mưa xối xả\nKìa ai đang thả thuyền lá\nKí ức trôi\nTrôi mãi tận miền xa.","tags":["thơ"],"text":"mưa,\nmưa trên mái hiên nhà\nđến tận cánh đồng xa\nmưa,\nmưa hoài, mưa xối xả\nkìa ai đang thả thuyền lá\nkí ức trôi\ntrôi mãi tận miền xa.\n","title":"Mưa"},{"date":"2021-10-20","image":"","imageAlt":"","link":"https://idev-blog.web.app/posts/poem-l%E1%BB%ADa-h%E1%BB%93ng/","summary":"Có một đốm than nhỏ\nThắp lên ngọn lửa hồng\nDành trọn nhiệt huyết nồng\nTháp sáng ước mơ to.","tags":["thơ"],"text":"có một đốm than nhỏ\nthắp lên ngọn lửa hồng\ndành trọn nhiệt huyết nồng\ntháp sáng ước mơ to.\n","title":"Lửa Hồng"}]
}

