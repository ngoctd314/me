<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>Dev&#39;s Log</title>
    <link>https://idev-blog.web.app/</link>
    <description>Recent content on Dev&#39;s Log</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Tran Duc Ngoc</copyright>
    <lastBuildDate>Fri, 10 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://idev-blog.web.app/index.xml" rel="self" type="application/rss+xml" /><icon>https://idev-blog.web.app/logo.png</icon>
    
    
    <item>
      <title>Ước mơ của mẹ</title>
      <link>https://idev-blog.web.app/posts/%C6%B0%E1%BB%9Bc-m%C6%A1-c%E1%BB%A7a-m%E1%BA%B9/</link>
      <pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/%C6%B0%E1%BB%9Bc-m%C6%A1-c%E1%BB%A7a-m%E1%BA%B9/</guid>
      <description><![CDATA[<p>Hello bạn, mình không biết bạn là ai, nhưng cảm ơn bạn vì đã ghé vào đây và nghe mình xàm xí. Bài viết này được viết lúc mình đang hơi tâm trạng, có thể làm ảnh hưởng đến bạn. Vậy nên bạn hãy cân nhắc tắt tivi hoặc chuyển kênh qua các kênh như <a href="https://idev-blog.web.app/tags/th%C6%A1/">#thơ</a> hoặc các bài về tech nhé. Cảm ơn nhiều nhiềuuu.</p>
<p><strong>À ừ, tuổi thơ của cậu thế nào nhỉ?</strong></p>
<p>Mỗi khi mình nghe ai đó kể vể tuổi thơ thì mình sẽ luôn nhận ra là nó đẹp. Mình cũng thế, mình lớn lên trong nghèo khó và nó cũng rất đẹp.</p>
<p><strong>À ừ, vài mảnh kí ức mà cậu còn nhớ?</strong></p>
<p>Không biết cậu thế nào, chứ mình nhớ rất nhiều chuyện từ hồi mình bé xíu xíu và hầu hết nó đều liên quan đến mẹ &hellip;
Còn nhớ cái hồi mình học lớp một, hồi đó nhà mình nghèo lắm. Bố, mẹ mình làm đủ nghề đánh cá, trồng cà phê, thu mua đồng nát &hellip; còn nhiều, nhiều lắm, mình cũng chả nhớ nổi nữa.</p>
<p>Mọi hôm thì mẹ sẽ chở mình đến trường, rồi sau đó sẽ đi thu mua đồng nát. Nhưng hôm ấy, mẹ chở mình xong tiện thể sẽ đi làm luôn. Đi đến gần trường, mẹ có hỏi mình rằng:</p>
<ul>
<li>Con có ngại với các bạn không?</li>
</ul>
<p>Hồi đó mình cũng chả hiểu câu hỏi của mẹ đâu. Mình trả lời là con không mẹ. Nhưng mà lúc đó mẹ vẫn không đưa mình đến tận cổng, mẹ dừng ở xa xa một chút &hellip;</p>
<p>Hồi đó, xung quanh nhà mình chả có ai cả, không làng, không xóm. Bố mẹ thì đi làm suốt, chỉ có hai chị em chơi với nhau thôi. Thân lắmmm. Còn nhớ vào mỗi mùa khô, bố mẹ phải đi tưới cà phê ở rẫy phải vài ngày mới về. Hai chị em ở nhà sợ lắm. Nhà mình còn chả có đèn điện. Tối đến hai chị em thắp nến lên, chắc hẳn ai cũng từng chỉ chỉ cái bóng khổng lồ xong chơi đùa với nó. Còn mình và chị thì bảo nó là mẹ. Mẹ dọa là tối thì không được mở cửa nhà, không thì trộm nó vào nhà đấy. Thế mà chị mình đóng vai là mẹ, xong hai chị em cứ xưng hô mẹ, con với nhau. Buồn cười lắm. À mình có viết một bài về cái vụ này, bạn có thể đọc ở <a href="https://idev-blog.web.app/posts/poem-hai-%C4%91%E1%BB%A9a-tr%E1%BA%BB/">đây</a> nhé :3</p>
<p>Hồi cuối năm lớp 3, chị mình đòi về miền bắc (trước đó mình ở  Tây Nguyên), bố mẹ mình cũng thấy trong đó điều kiện học hành không tốt, nên cho cả mình về. Mình vui lắm. Nhưng mình đâu có biết, là mình sẽ về sống với ông bà thôi, còn bố mẹ thì vẫn phải đi làm ở trong đó.</p>
<p>Mình nhớ có một lần mẹ về quê thăm con. Trước tối hôm mẹ quay lại miền nam, mình bảo mẹ lúc nào mẹ dậy thì mẹ bảo con với nhé. Mình còn cẩn thận lấy cái dây, buộc tay mình với mẹ lại, lúc đó mình sợ mẹ không gọi mình dậy. Mình nhớ như in lúc 4h sáng hôm đấy, mình vẫn dậy được. Lúc mẹ chuẩn bị đi, mình chạy đến ôm chân mẹ, khóc nức nở, không cho mẹ đi. Mình cũng không nhớ mình nói gì với mẹ, chỉ nhớ mang máng là con không cho mẹ đi, mẹ ở nhà với con. Mình khóc to, to lắm, to đến nỗi cả xóm sang khuyên mình cơ mà. Bình thường mình mà khóc thì mẹ còn đánh thêm cho, nhưng hôm đấy dĩ nhiên là khác &hellip;</p>
<h2 id="à-ừ-mẹ-khóc">À ừ, mẹ khóc</h2>
<p>Mẹ mình khóc nhiều lắm. Bà ngoại có nói với mình là, trong cái nhà này không ai khổ bằng bà với mẹ (à mà mình có người bà tuyệt vời lắm, nếu có khúc mắc, chuyện buồn gì mà nói với bà là lúc sau sẽ được giải tỏa ngay. Ước gì mình có thể nói chuyện giỏi như bà :3).</p>
<p>Hồi chị mình học năm 3, chị mình thấy không phù hợp nên đã bỏ học. Đấy là lần đầu tiên mình thấy bố khóc. Còn mẹ thì khóc cả ngày.</p>
<p>Còn hôm nay mình cũng làm mẹ khóc. Mẹ mình có ước mơ là mình học ThS, mình đã nhận lời rồi, ấy thế mà hôm nay mình lại định bỏ. À mà không phải là mình không muốn học ThS đâu, mà mình đang có một vài dự định khác, thôi thì cân tất vậy :3</p>
<p><img src="../../images/confide/m%E1%BA%B9.png" alt="mẹ"></p>
<p>Mình làm mẹ khóc nhiều lắm, nhưng mà thôi không dám kể :))</p>
<p> </p>
<p>Cảm ơn bạn đã đọc đến tận lúc này, nếu được thì ib để  mình mời cf nhé. Cảm ơn nhiều nhiềuuu.</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Automatic connect to VPN</title>
      <link>https://idev-blog.web.app/posts/linux-auto-connect-openvpn/</link>
      <pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/linux-auto-connect-openvpn/</guid>
      <description><![CDATA[<p>The OpenVPN is an open source Virtual Private Network (VPN) project. It creates secure connections over the Internet using a custom security protocol that utilizes SSL/TLS.</p>
<p>In this article, i will introduce naive solution for automatic connect to VPN using openvpn and systemd management.</p>
<p><strong>Create vpn script</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># Create script connect to vpn</span>
</span></span><span style="display:flex;"><span>mkdir -p ~/scripts
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">cd</span> ~/scripts
</span></span><span style="display:flex;"><span>touch vpn.sh
</span></span><span style="display:flex;"><span>sudo chmod +x vpn.sh
</span></span></code></pre></div><p><strong>Install oauthtool</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install oathtool 
</span></span></code></pre></div><p><strong>~/scripts/vpn.sh</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">VPN_USER</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;&#34;</span> <span style="color:#6272a4"># insert vpn user here</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">VPN_PASSWORD</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;&#34;</span>  <span style="color:#6272a4"># insert vpn password here</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">OTP_KEY</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;&#34;</span> <span style="color:#6272a4"># insert otp key here</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">OVPN_FILE</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;&#34;</span> <span style="color:#6272a4"># insert path to .ovpn file here. example /home/admicro-bigdata.ovpn</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">VPN_AUTH</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;</span><span style="color:#ff79c6">$(</span>oathtool -b --totp <span style="color:#8be9fd;font-style:italic">$OTP_KEY</span><span style="color:#ff79c6">)</span><span style="color:#8be9fd;font-style:italic">$VPN_PASSWORD</span><span style="color:#f1fa8c">&#34;</span> 
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">echo</span> <span style="color:#8be9fd;font-style:italic">$VPN_PASSWORD</span> | sudo -S bash -c <span style="color:#f1fa8c">&#34;openvpn --config </span><span style="color:#8be9fd;font-style:italic">$OVPN_FILE</span><span style="color:#f1fa8c"> --auth-user-pass &lt;(echo -e &#39;</span><span style="color:#8be9fd;font-style:italic">$VPN_USER</span><span style="color:#f1fa8c">\n</span><span style="color:#8be9fd;font-style:italic">$VPN_AUTH</span><span style="color:#f1fa8c">&#39;) --daemon&#34;</span>
</span></span></code></pre></div><p><strong>Create systemd service</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">cd</span> /lib/systemd/system
</span></span><span style="display:flex;"><span>sudo touch vpn.service
</span></span></code></pre></div><p><strong>/lib/systemd/system/vpn.service</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>[Unit]
</span></span><span style="display:flex;"><span>Description=Auto connect vccorp&#39;s vpn service.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[Service]
</span></span><span style="display:flex;"><span>Type=forking
</span></span><span style="display:flex;"><span>User=root
</span></span><span style="display:flex;"><span># path to vpn file, example: /home/ngoctd/scripts/vpn.sh
</span></span><span style="display:flex;"><span>ExecStart=/bin/bash /home/ngoctd/scripts/vpn.sh
</span></span><span style="display:flex;"><span># path to vpn file, example: /home/ngoctd/scripts/vpn.sh
</span></span><span style="display:flex;"><span>ExecReload= /bin/bash /home/ngoctd/scripts/vpn.sh
</span></span><span style="display:flex;"><span>ExecStop=sudo killall openvpn
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Restart=on-failure
</span></span><span style="display:flex;"><span>RestartSec=10s
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[Install]
</span></span><span style="display:flex;"><span>WantedBy=multi-user.target
</span></span></code></pre></div><p><strong>start,stop,auto restart service</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl daemon-reload <span style="color:#6272a4"># reload systemd daemon</span>
</span></span><span style="display:flex;"><span>sudo systemctl <span style="color:#8be9fd;font-style:italic">enable</span> vpn <span style="color:#6272a4"># auto start when vpn was killed</span>
</span></span><span style="display:flex;"><span>sudo systemctl start vpn <span style="color:#6272a4"># start vpn</span>
</span></span><span style="display:flex;"><span>sudo systemctl status vpn <span style="color:#6272a4"># check vpn status</span>
</span></span><span style="display:flex;"><span>sudo systemctl stop vpn <span style="color:#6272a4"># stop vpn</span>
</span></span></code></pre></div>]]></description>
      
    </item>
    
    
    
    <item>
      <title>Channel in Golang</title>
      <link>https://idev-blog.web.app/posts/programming-language-channel-in-golang/</link>
      <pubDate>Sat, 05 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/programming-language-channel-in-golang/</guid>
      <description><![CDATA[<p>Channel is an important built-in feature in Go. It is one of the features makes Go unique. Channel makes concurrent programming convenient, fun and lowers the difficulties of concurrent programming. Channel mainly acts as a concurrency synchronization technique. To understand channels better, the internal structure of channels and some implementation details by the standard Go compiler/runtime are also simply described.</p>
<h2 id="channel-introduction">Channel Introduction</h2>
<p>Don&rsquo;t communicate by sharing memory, share memory by communicating.</p>
<p>Communicating by sharing memory and sharing by communicating are two programming manners in concurrent programming. When goroutines communicate by sharing memory, we use traditional concurrency sychronization techniques, such as mutex locks, to protect the shared memory to prevent data racts.</p>
<p>Go also provides another concurrency sychronization technique, channel. Channels make goroutines share memory by communicating. We can view a channel as an internal FIFO queu within a program. Some goroutines send values to the queue (the channel) and some other goroutines receive values from the queue.</p>
<p>Along with transfering values (through channels), the ownership of some values may also be transferred between goroutines (ownership on logic view). When a goroutine send a value to a channel, we can view the goroutine releases the ownership of some values. When a goroutine receives a value from a channel, we can view the goroutine acquires the ownerships of some values.</p>
<h2 id="channel-value-comparisons">Channel Value Comparisons</h2>
<p>All channel types are comparable types.
If one channel value is assigned to another, the two channels share the same underlying part(s). In other words, those two channels represent the same internal channel object. The result of comparing them is true.</p>
<h2 id="detailed-explanations-for-channel-operations">Detailed Explanations for Channel Operations</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>A Nil Channel</th>
<th>A Closed Channel</th>
<th>A Not-Closed Non-Nil Channel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Close</td>
<td>panic</td>
<td>panic</td>
<td>success</td>
</tr>
<tr>
<td>Send Value To</td>
<td>block for ever</td>
<td>panic</td>
<td>block or succeed to send</td>
</tr>
<tr>
<td>Receive value from</td>
<td>block for ever</td>
<td>never block</td>
<td>block or success to receive</td>
</tr>
</tbody>
</table>
<p>To bettern understand channel types and values, and to make some explainations easier, looking in the raw internal structures of internal channel objects is very helpful.</p>
<p>We can think of each channel consistin of three queues internally:</p>
<ol>
<li>
<p>The receiving goroutine queue (generally FIFO). The queue is a linked list without size limitation. Goroutines in this queue are all in blocking state and waiting to receive values from that channel.</p>
</li>
<li>
<p>The sending goroutine queue (generally FIFO). The queue is also a linked list without size limitation. Goroutines in this queue are all in blocking state and waiting to send values to that channel.</p>
</li>
<li>
<p>The value buffer queue (absolutely FIFO). This is a circular queue. Its size is equal to the capacity of the channel. If the current number of values stored in the value buffer queue of the channel reaches the capacity of the channel, the channel is called in full status. If no values are store in the value buffer queue of the channel currently, the channel is called in empty status. For a zero-capacity (unbuffered) channel is also in both full and empty status.</p>
</li>
</ol>
<p><strong>Each channel internally holds a mutex lock which is used to avoid data races in all kinds of operations</strong></p>
<h3 id="channel-operation-try-to-receive">Channel operation: try to receive</h3>
<p>When a goroutine R tries to receive a value from a not-closed non-nil channel, the goroutine R will acquire the lock associated with the channel firstly, the do the following steps until one condition is satisfied.</p>
<ol>
<li>Check buffer, if the value buffer queue of the channel is not empty. The receiving goroutine queue of the channel must be empty ( buffer != empty =&gt; receiveing queue == emtpy ). The goroutine R will receive (by unshifting) a value from the value buffer queue. If the sending goroutine queue of the channel is also not empty, a sending goroutine will be unshifted out of the sending goroutine queue and resumed to running state again. The value the just unshifted sending goroutine trying to send will be pushed into the value buffer queue of the channel. The receiving goroutine R continues running. For this scenario, the channel receive operation is called a non-blocking operation.</li>
</ol>
<ul>
<li>The goroutine R will receive a value from the value buffer queue.</li>
</ul>
<p><img src="../../images/channel%20golang/receive1.png" alt="receive value from buffer, sending goroutine queue is empty"></p>
<ul>
<li>The goroutine R will recceive a value from the value buffer queue. Sending goroutine is not empty. Goroutine S send value to buffer and enter running state again.</li>
</ul>
<p><img src="../../images/channel%20golang/receive2.png" alt="receive value from buffer, sending goroutine is not emtpy"></p>
<p><strong>-&gt; The receiving goroutine R continues running. The channel receive operation is called a non-blocking operation</strong></p>
<ol start="2">
<li>Check buffer, the value buffer of the channel is empty. If the sending goroutine queue of the channel is not empty, in which case the channel must be an unbuffered channel, the receiving goroutine R will unshift value from a send goroutine. The just unshifted sending goroutine will get unblocked and resumed to running state again.</li>
</ol>
<p><img src="../../images/channel%20golang/receive3.png" alt="receive value from buffer, sending goroutine is not emtpy"></p>
<p><strong>-&gt; The receiving goroutine R continues running. The channel receive operation is called a non-blocking operation</strong></p>
<ol start="3">
<li>If value buffer queue and the sending goroutine queue of the channel are both emtpy, the goroutine R will be pushed into the receiving goroutine queue of the channel and enter (and stay in) blocking state. It may be resumed to running state when another goroutine sends a value to the channel later.</li>
</ol>
<p><img src="../../images/channel%20golang/receive4.png" alt="receive value from buffer, sending goroutine is not emtpy"></p>
<p><strong>-&gt; The receiving goroutine R enter blocking state. The channel receive operation is called a blocking operation</strong></p>
<h3 id="channel-operation-try-to-send">Channel operation: try to send</h3>
<p>When a goroutine S tries to send a value to a not-closed non-nil channel, the goroutine S will acquire the lock associated with the channel firstly, then do the following steps until one step condition is satisfied.</p>
<ol>
<li>Check receiving goroutine queue. If the receiving goroutine queue of the channel is not empty, in which case the value buffer queue of the channel must be empty, the sending goroutine S will unshift a receiving goroutine from the receiving goroutine queue of the  channel and send the value to the just unshifted receiving goroutine. The just unshifted receiving goroutine will get unblocked and resumed to running state again.</li>
</ol>
<p><img src="../../images/channel%20golang/send1.png" alt="send value"></p>
<p><strong>-&gt; The sending goroutine S continues running. The channel send operation is called a non-blocking operation</strong></p>
<ol start="2">
<li>Check receiving goroutine queue (empty), check buffer queue ( not full ), in which case the sending goroutine queue must be also empty, the value the sending goroutine S trying to send will be pushed into the value buffer queue.</li>
</ol>
<p><img src="../../images/channel%20golang/send2.png" alt="send value"></p>
<p><strong>-&gt; The sending goroutine S continues running. The channel send operation is called a non-blocking operation</strong></p>
<ol start="3">
<li>Check receiving goroutine queue (empty), check buffer queue ( full ), the sending goroutine S will be pushed into the sending goroutine queue of the channel and enter (and stay in) blocking state. It may be resumed to running state when another goroutine receives a value from the channel later.</li>
</ol>
<p><img src="../../images/channel%20golang/send3.png" alt="send value"></p>
<p><strong>-&gt; The sending goroutine S enter blocking. The channel send operation is called a blocking operation</strong></p>
<p>Once a non-nil channel is closed, sending a value to the channel will produce a runtime panic in the current goroutine. Note sending data to a closed channel is viewed as a non-blocking operation.</p>
<h3 id="channel-operation-try-to-close">Channel operation: try to close</h3>
<p>When a goroutine tries to close a not-closed non-nil channel, once the goroutine has acquired the lock of the channel, both of the following two steps will be performed by the following order.</p>
<ol>
<li>If the receiving goroutine queue of the channel is not empty, in which case the value buffer of the channel must be empty, all the goroutines in the receiving goroutine queue of the channel will be unshifted one by one, each of themm will receive a zero value of the elemenet type of the channel and be resumed to running state.</li>
</ol>
<p><img src="../../images/channel%20golang/close1.png" alt="send value"></p>
<ol start="2">
<li>If the sending goroutine queue of the channel is not empty, all the goroutines in the sending goroutine queue of the channel will be unshifted one by one and each of them will produce a panic for sending on a closed channel. This is the reason why we should avoid concurrent send and close operations on the same channel.</li>
</ol>
<p>After a channel is closed, the values which have been already pushed into the value buffer of the channel are still there.</p>
<p><strong>After a non-nil channel is closed, channel receive operations os the channel will never block</strong></p>
<h3 id="some-facts-about-the-internal-queues-of-a-channel">Some facts about the internal queues of a channel</h3>
<ul>
<li>If the channel is closed, both its sending and receiving goroutine queue must be empty, but its value buffer may not be empty.</li>
<li>At any time, if the value buffer is not empty, then its receiving goroutine queue must be empty.</li>
<li>At any time, if the value buffer is not full, then its sending goroutine queue must be empty.</li>
<li>If the channel is buffered, then at time, at least one of the channel&rsquo;s goroutine queues must be empty (sending, receiving or both).</li>
<li>If the channel is unbuffered, most of the time one of its sending goroutine queue and the receiving goroutine queue must be empty, with one exception. The exception is that a goroutine may be pushed into both of the two queues when execution a select control flow code block.</li>
</ul>
<p><strong>References</strong> <a href="https://go101.org/article/channel.html">Channel Use Case go101</a></p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Hai Đứa Trẻ</title>
      <link>https://idev-blog.web.app/posts/poem-hai-%C4%91%E1%BB%A9a-tr%E1%BA%BB/</link>
      <pubDate>Thu, 13 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/poem-hai-%C4%91%E1%BB%A9a-tr%E1%BA%BB/</guid>
      <description><![CDATA[<p>Hai đứa trẻ lớn lên nơi rừng núi</p>
<p>Xung quanh nhà nào là cỏ, là cây</p>
<p>Hai đứa trẻ là chị là em, và là bạn</p>
<p>Bạn bè xung quanh, hiếm lắm ấy mà.</p>
<p> </p>
<p>Hai đứa trẻ nhiều đêm khó ngủ</p>
<p>Bố mẹ đi rẫy mãi chưa về</p>
<p>Hai đứa trẻ ngồi bên ngọn nến sáng</p>
<p>Chỉ bóng trên tường, gọi mẹ xưng con.</p>
<p> </p>
<p>Hai đứa trẻ rời xa nơi nương náu</p>
<p>Bố mẹ lo chuyện học hành mai sau</p>
<p>Hai đứa trẻ là chị là em, không là bạn</p>
<p>Nhảy dây, bị mắt, thú vị hơn nhiều.</p>
<p> </p>
<p>Hai đứa trẻ mai này rồi cũng lớn</p>
<p>Đứa rời xóm làng, đứa tìm thủ đô</p>
<p>Hai đứa trẻ hiếm nào khi hỏi chuyện</p>
<p>Chuyện học hành, chuyện tương lai, chuyện mai sau</p>
<p>Hai đứa trẻ, hai đứa trẻ ấy không còn&hellip;</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Mưa</title>
      <link>https://idev-blog.web.app/posts/poem-m%C6%B0a/</link>
      <pubDate>Fri, 11 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/poem-m%C6%B0a/</guid>
      <description><![CDATA[<p>Mưa,</p>
<p>Mưa trên mái hiên nhà</p>
<p>Đến tận cánh đồng xa</p>
<p>Mưa,</p>
<p>Mưa hoài, mưa xối xả</p>
<p>Kìa ai đang thả thuyền lá</p>
<p>Kí ức trôi</p>
<p>Trôi mãi tận miền xa.</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Lửa Hồng</title>
      <link>https://idev-blog.web.app/posts/poem-l%E1%BB%ADa-h%E1%BB%93ng/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/poem-l%E1%BB%ADa-h%E1%BB%93ng/</guid>
      <description><![CDATA[<p>Có một đốm than nhỏ</p>
<p>Thắp lên ngọn lửa hồng</p>
<p>Dành trọn nhiệt huyết nồng</p>
<p>Tháp sáng ước mơ to.</p>
]]></description>
      
    </item>
    
    
    
    
    
    
    
    <item>
      <title>Tổng hợp ví dụ về channel trong golang</title>
      <link>https://idev-blog.web.app/posts/golang-channel-usecase/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/golang-channel-usecase/</guid>
      <description><![CDATA[]]></description>
      
    </item>
    
    
  </channel>
</rss>
