<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>Dev&#39;s Log</title>
    <link>https://idev-blog.web.app/</link>
    <description>Recent content on Dev&#39;s Log</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Tran Duc Ngoc</copyright>
    <lastBuildDate>Sat, 26 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://idev-blog.web.app/index.xml" rel="self" type="application/rss+xml" /><icon>https://idev-blog.web.app/logo.png</icon>
    
    
    <item>
      <title>Pipelines and cancellation</title>
      <link>https://idev-blog.web.app/posts/concurrency-pattern-pipeline-and-cancellation/</link>
      <pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/concurrency-pattern-pipeline-and-cancellation/</guid>
      <description><![CDATA[<p>Go&rsquo;s concurrency primitives make it easy to construct streaming data pipelines that make efficient use of I/O and multiple CPUs. This article introduces what is pipeline, how to to construct a pipeline and introduces techniques for dealing with failures cleanly.</p>
<h2 id="what-is-a-pipeline">What is a pipeline?</h2>
<p>A pipeline is a series of stages connected by channels, where each channel is a group of goroutines running the same function. In each stage, the goroutines</p>
<ul>
<li>receive values from upstream via inbound channels</li>
<li>perform some function on that data, usually producing new values</li>
<li>send the values downstream via outbound channels</li>
</ul>
<p>Each stage has any number of inbound and outbound channels, except the first and last stages, which have only outbound or inbound channels. The first stage is sometimes called the source and producer; the last stage, the sink or consumer.</p>
<h2 id="squaring-numbers">Squaring numbers</h2>
<p>Consider a pipeline with three stages</p>
<p>The first stage, gen, is a function that converts a list of integers to a channel that emits the integers in the list.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6272a4">// the main function sets up the pipeline and runs the final stages
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// it receives values from the second stage and prints each one, until the channel is closed
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// a pipeline
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	c <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">gen</span>(<span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>)
</span></span><span style="display:flex;"><span>	out <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">sq</span>(c)
</span></span><span style="display:flex;"><span>	fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#ff79c6">&lt;-</span>out)
</span></span><span style="display:flex;"><span>	fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#ff79c6">&lt;-</span>out)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// The gen function starts a goroutine that sends the integers on the channel and closes the channel when all the values have been sent:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">gen</span>(nums <span style="color:#ff79c6">...</span><span style="color:#8be9fd">int</span>) <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>	out <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">int</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">for</span> _, n <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> nums {
</span></span><span style="display:flex;"><span>			out <span style="color:#ff79c6">&lt;-</span> n
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">close</span>(out)
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> out
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// The second stage, sq receives integers from a channel and returns a channel that emits the square of each received integer.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// After the inbound channel is closed and this stage has sent all the values downstream, it closes the outbound channel
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">sq</span>(in <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">int</span>) <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>	out <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">int</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">for</span> n <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> in {
</span></span><span style="display:flex;"><span>			out <span style="color:#ff79c6">&lt;-</span> n <span style="color:#ff79c6">*</span> n
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">close</span>(out)
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> out
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="fan-in-fan-out">Fan-in, Fan-out</h2>
<h2 id="stopping-short">Stopping Short</h2>
<p>There is  a pattern to our pipeline functions:</p>
<ul>
<li>stages close their outbound channels when all the send operations are done.</li>
<li>stages keep receiving value from inbound channels until those channel are closed.</li>
</ul>
<p>This pattern allows each receiving stage to be written as for range loop and ensures that all goroutines exit once all values have been successfully sent downstream.</p>
<p>But in real pipelines, stages don&rsquo;t always receive all the inbound values. Sometimes this is by design: the receiver may only need a subset of values to make progress. More often, a stage exit early because an inbound value represents an error in a earlier stages to stop producing values that later stage don&rsquo;t need.</p>
<p><strong>References</strong></p>
<ul>
<li><a href="https://go.dev/blog/pipelines">https://go.dev/blog/pipelines</a></li>
</ul>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Channel Use Case in Golang</title>
      <link>https://idev-blog.web.app/posts/programming-language-channel-usecase/</link>
      <pubDate>Tue, 22 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/programming-language-channel-usecase/</guid>
      <description><![CDATA[<p>This article will show many channel use cases</p>
<ul>
<li>Asynchronous and concurrency programing with Go channels is easy and enjoyable.</li>
<li>The channel synchronization technique has wider range of uses and have more variables than the synchronization solutions used in some other languages, such as the actor model and the async/await pattern.</li>
</ul>
<h2 id="use-channels-as-futurespromises">Use Channels as Futures/Promises</h2>
<p><strong>Return receive-only channels as results</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">longTimeRequest</span>() <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{} {
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// simulate workload run 3s in using goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		time.<span style="color:#50fa7b">Sleep</span>(time.Second <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">3</span>)
</span></span><span style="display:flex;"><span>		ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// return immediately
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> ch
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ch1 <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">longTimeRequest</span>()
</span></span><span style="display:flex;"><span>	ch2 <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">longTimeRequest</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	_, _ = <span style="color:#ff79c6">&lt;-</span>ch1, <span style="color:#ff79c6">&lt;-</span>ch2 <span style="color:#6272a4">// get result in future
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;exec in: &#34;</span>, time.<span style="color:#50fa7b">Since</span>(now)) <span style="color:#6272a4">// ~ 3s
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><p><strong>Pass send-only channels as arguments</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">longTimeRequest</span>(ch <span style="color:#8be9fd;font-style:italic">chan</span><span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// simulate workload run 3s in using goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;send value to channel&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// buffer = 2 to avoid block to handle channle receive
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}, <span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">longTimeRequest</span>(ch)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">longTimeRequest</span>(ch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span>ch
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span>ch
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;exec in: &#34;</span>, time.<span style="color:#50fa7b">Since</span>(now))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>The first response win</strong></p>
<p>Sometimes, a piece of data can be received from several sources to avoid high latencies. For a lot of factors, the response durations of these sources may vary much. To make the response duration as short as possible, we can send a request to every source in separated goroutine. Only the first response use case will be used, other slower ones will be discarded.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">source</span>(c <span style="color:#8be9fd;font-style:italic">chan</span><span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>	c <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// c must be a buffered channel
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// If there are N sources, the capacity of the communication channel must be at least N-1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// to avoid the goroutines corresponding the discarded responses being blocked for ever
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	c <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}, <span style="color:#bd93f9">5</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; <span style="color:#8be9fd;font-style:italic">cap</span>(c); i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">source</span>(c)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// first response win
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">&lt;-</span>c
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="use-channels-for-notifications">Use Channels for Notifications</h2>
<p>Notifications can be viewed as special requests/responses in which the responded values are not important. Generally, we use the blank type struct{} as the element types of the notification channels.</p>
<p><strong>1-to-1 notification by sending a value to a channel</strong></p>
<p>If there are no values to be received from a channel, then the next receive operation on the channel will block until another goroutine sends a value to the channel. So we can send a value to a channel to notify another goroutine which is waiting to receive a value from the same channel.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">blocking</span>(c <span style="color:#8be9fd;font-style:italic">chan</span><span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>	time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// unlock by notifycation
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	c <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">blocking</span>(ch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// blocking
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">&lt;-</span>ch
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;since: &#34;</span>, time.<span style="color:#50fa7b">Since</span>(now))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> os.Signal)
</span></span><span style="display:flex;"><span>	signal.<span style="color:#50fa7b">Notify</span>(sig, os.Interrupt)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span>sig
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>1-to-1 notification by receiving a value from a channel</strong></p>
<p>If the value buffer queue of a channel is full (the buffer queue of an unbuffered channel is always full), a send operation on the channel will block until another goroutine receives a value from the channel. So we can receive a value from a channel to notify another goroutine which is waiting to send a value to the same channel.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">blocking</span>(c <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>	time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// unblock the second send in main goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">&lt;-</span>c
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">blocking</span>(ch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// blocked here, wait for a notification
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;since: &#34;</span>, time.<span style="color:#50fa7b">Since</span>(now))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> os.Signal)
</span></span><span style="display:flex;"><span>	signal.<span style="color:#50fa7b">Notify</span>(sig, os.Interrupt)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span>sig
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>N-to-1 and 1-to-N notifications</strong></p>
<p>Broadcast (1-to-N) notifications by closing a channel</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Automatic connect to VPN</title>
      <link>https://idev-blog.web.app/posts/linux-auto-connect-openvpn/</link>
      <pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/linux-auto-connect-openvpn/</guid>
      <description><![CDATA[<p>The OpenVPN is an open source Virtual Private Network (VPN) project. It creates secure connections over the Internet using a custom security protocol that utilizes SSL/TLS.</p>
<p>In this article, i will introduce naive solution for automatic connect to VPN using openvpn and systemd management.</p>
<p><strong>Create vpn script</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># Create script connect to vpn</span>
</span></span><span style="display:flex;"><span>mkdir -p ~/scripts
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">cd</span> ~/scripts
</span></span><span style="display:flex;"><span>touch vpn.sh
</span></span><span style="display:flex;"><span>sudo chmod +x vpn.sh
</span></span></code></pre></div><p><strong>Install oauthtool</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install oathtool 
</span></span></code></pre></div><p><strong>~/scripts/vpn.sh</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">VPN_USER</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;&#34;</span> <span style="color:#6272a4"># insert vpn user here</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">VPN_PASSWORD</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;&#34;</span>  <span style="color:#6272a4"># insert vpn password here</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">OTP_KEY</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;&#34;</span> <span style="color:#6272a4"># insert otp key here</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">OVPN_FILE</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;&#34;</span> <span style="color:#6272a4"># insert path to .ovpn file here. example /home/admicro-bigdata.ovpn</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">VPN_AUTH</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;</span><span style="color:#ff79c6">$(</span>oathtool -b --totp <span style="color:#8be9fd;font-style:italic">$OTP_KEY</span><span style="color:#ff79c6">)</span><span style="color:#8be9fd;font-style:italic">$VPN_PASSWORD</span><span style="color:#f1fa8c">&#34;</span> 
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">echo</span> <span style="color:#8be9fd;font-style:italic">$VPN_PASSWORD</span> | sudo -S bash -c <span style="color:#f1fa8c">&#34;openvpn --config </span><span style="color:#8be9fd;font-style:italic">$OVPN_FILE</span><span style="color:#f1fa8c"> --auth-user-pass &lt;(echo -e &#39;</span><span style="color:#8be9fd;font-style:italic">$VPN_USER</span><span style="color:#f1fa8c">\n</span><span style="color:#8be9fd;font-style:italic">$VPN_AUTH</span><span style="color:#f1fa8c">&#39;) --daemon&#34;</span>
</span></span></code></pre></div><p><strong>Create systemd service</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">cd</span> /lib/systemd/system
</span></span><span style="display:flex;"><span>sudo touch vpn.service
</span></span></code></pre></div><p><strong>/lib/systemd/system/vpn.service</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>[Unit]
</span></span><span style="display:flex;"><span>Description=Auto connect vccorp&#39;s vpn service.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[Service]
</span></span><span style="display:flex;"><span>Type=forking
</span></span><span style="display:flex;"><span>User=root
</span></span><span style="display:flex;"><span># path to vpn file, example: /home/ngoctd/scripts/vpn.sh
</span></span><span style="display:flex;"><span>ExecStart=/bin/bash /home/ngoctd/scripts/vpn.sh
</span></span><span style="display:flex;"><span># path to vpn file, example: /home/ngoctd/scripts/vpn.sh
</span></span><span style="display:flex;"><span>ExecReload= /bin/bash /home/ngoctd/scripts/vpn.sh
</span></span><span style="display:flex;"><span>ExecStop=sudo killall openvpn
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Restart=on-failure
</span></span><span style="display:flex;"><span>RestartSec=10s
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[Install]
</span></span><span style="display:flex;"><span>WantedBy=multi-user.target
</span></span></code></pre></div><p><strong>start,stop,auto restart service</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl daemon-reload <span style="color:#6272a4"># reload systemd daemon</span>
</span></span><span style="display:flex;"><span>sudo systemctl <span style="color:#8be9fd;font-style:italic">enable</span> vpn <span style="color:#6272a4"># auto start when vpn was killed</span>
</span></span><span style="display:flex;"><span>sudo systemctl start vpn <span style="color:#6272a4"># start vpn</span>
</span></span><span style="display:flex;"><span>sudo systemctl status vpn <span style="color:#6272a4"># check vpn status</span>
</span></span><span style="display:flex;"><span>sudo systemctl stop vpn <span style="color:#6272a4"># stop vpn</span>
</span></span></code></pre></div>]]></description>
      
    </item>
    
    
    
    <item>
      <title>Channel in Golang</title>
      <link>https://idev-blog.web.app/posts/programming-language-channel-in-golang/</link>
      <pubDate>Sat, 05 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/programming-language-channel-in-golang/</guid>
      <description><![CDATA[<p>Channel is an important built-in feature in Go. It is one of the features makes Go unique. Channel makes concurrent programming convenient, fun and lowers the difficulties of concurrent programming. Channel mainly acts as a concurrency synchronization technique. To understand channels better, the internal structure of channels and some implementation details by the standard Go compiler/runtime are also simply described.</p>
<h2 id="channel-introduction">Channel Introduction</h2>
<p>Don&rsquo;t communicate by sharing memory, share memory by communicating.</p>
<p>Communicating by sharing memory and sharing by communicating are two programming manners in concurrent programming. When goroutines communicate by sharing memory, we use traditional concurrency sychronization techniques, such as mutex locks, to protect the shared memory to prevent data racts.</p>
<p>Go also provides another concurrency sychronization technique, channel. Channels make goroutines share memory by communicating. We can view a channel as an internal FIFO queu within a program. Some goroutines send values to the queue (the channel) and some other goroutines receive values from the queue.</p>
<p>Along with transfering values (through channels), the ownership of some values may also be transferred between goroutines (ownership on logic view). When a goroutine send a value to a channel, we can view the goroutine releases the ownership of some values. When a goroutine receives a value from a channel, we can view the goroutine acquires the ownerships of some values.</p>
<h2 id="channel-value-comparisons">Channel Value Comparisons</h2>
<p>All channel types are comparable types.
If one channel value is assigned to another, the two channels share the same underlying part(s). In other words, those two channels represent the same internal channel object. The result of comparing them is true.</p>
<h2 id="detailed-explanations-for-channel-operations">Detailed Explanations for Channel Operations</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>A Nil Channel</th>
<th>A Closed Channel</th>
<th>A Not-Closed Non-Nil Channel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Close</td>
<td>panic</td>
<td>panic</td>
<td>success</td>
</tr>
<tr>
<td>Send Value To</td>
<td>block for ever</td>
<td>panic</td>
<td>block or succeed to send</td>
</tr>
<tr>
<td>Receive value from</td>
<td>block for ever</td>
<td>never block</td>
<td>block or success to receive</td>
</tr>
</tbody>
</table>
<p>To bettern understand channel types and values, and to make some explainations easier, looking in the raw internal structures of internal channel objects is very helpful.</p>
<p>We can think of each channel consistin of three queues internally:</p>
<ol>
<li>
<p>The receiving goroutine queue (generally FIFO). The queue is a linked list without size limitation. Goroutines in this queue are all in blocking state and waiting to receive values from that channel.</p>
</li>
<li>
<p>The sending goroutine queue (generally FIFO). The queue is also a linked list without size limitation. Goroutines in this queue are all in blocking state and waiting to send values to that channel.</p>
</li>
<li>
<p>The value buffer queue (absolutely FIFO). This is a circular queue. Its size is equal to the capacity of the channel. If the current number of values stored in the value buffer queue of the channel reaches the capacity of the channel, the channel is called in full status. If no values are store in the value buffer queue of the channel currently, the channel is called in empty status. For a zero-capacity (unbuffered) channel is also in both full and empty status.</p>
</li>
</ol>
<p><strong>Each channel internally holds a mutex lock which is used to avoid data races in all kinds of operations</strong></p>
<h3 id="channel-operation-try-to-receive">Channel operation: try to receive</h3>
<p>When a goroutine R tries to receive a value from a not-closed non-nil channel, the goroutine R will acquire the lock associated with the channel firstly, the do the following steps until one condition is satisfied.</p>
<ol>
<li>Check buffer, if the value buffer queue of the channel is not empty. The receiving goroutine queue of the channel must be empty ( buffer != empty =&gt; receiveing queue == emtpy ). The goroutine R will receive (by unshifting) a value from the value buffer queue. If the sending goroutine queue of the channel is also not empty, a sending goroutine will be unshifted out of the sending goroutine queue and resumed to running state again. The value the just unshifted sending goroutine trying to send will be pushed into the value buffer queue of the channel. The receiving goroutine R continues running. For this scenario, the channel receive operation is called a non-blocking operation.</li>
</ol>
<ul>
<li>The goroutine R will receive a value from the value buffer queue.</li>
</ul>
<p><img src="../../images/channel%20golang/receive1.png" alt="receive value from buffer, sending goroutine queue is empty"></p>
<ul>
<li>The goroutine R will recceive a value from the value buffer queue. Sending goroutine is not empty. Goroutine S send value to buffer and enter running state again.</li>
</ul>
<p><img src="../../images/channel%20golang/receive2.png" alt="receive value from buffer, sending goroutine is not emtpy"></p>
<p><strong>-&gt; The receiving goroutine R continues running. The channel receive operation is called a non-blocking operation</strong></p>
<ol start="2">
<li>Check buffer, the value buffer of the channel is empty. If the sending goroutine queue of the channel is not empty, in which case the channel must be an unbuffered channel, the receiving goroutine R will unshift value from a send goroutine. The just unshifted sending goroutine will get unblocked and resumed to running state again.</li>
</ol>
<p><img src="../../images/channel%20golang/receive3.png" alt="receive value from buffer, sending goroutine is not emtpy"></p>
<p><strong>-&gt; The receiving goroutine R continues running. The channel receive operation is called a non-blocking operation</strong></p>
<ol start="3">
<li>If value buffer queue and the sending goroutine queue of the channel are both emtpy, the goroutine R will be pushed into the receiving goroutine queue of the channel and enter (and stay in) blocking state. It may be resumed to running state when another goroutine sends a value to the channel later.</li>
</ol>
<p><img src="../../images/channel%20golang/receive4.png" alt="receive value from buffer, sending goroutine is not emtpy"></p>
<p><strong>-&gt; The receiving goroutine R enter blocking state. The channel receive operation is called a blocking operation</strong></p>
<h3 id="channel-operation-try-to-send">Channel operation: try to send</h3>
<p>When a goroutine S tries to send a value to a not-closed non-nil channel, the goroutine S will acquire the lock associated with the channel firstly, then do the following steps until one step condition is satisfied.</p>
<ol>
<li>Check receiving goroutine queue. If the receiving goroutine queue of the channel is not empty, in which case the value buffer queue of the channel must be empty, the sending goroutine S will unshift a receiving goroutine from the receiving goroutine queue of the  channel and send the value to the just unshifted receiving goroutine. The just unshifted receiving goroutine will get unblocked and resumed to running state again.</li>
</ol>
<p><img src="../../images/channel%20golang/send1.png" alt="send value"></p>
<p><strong>-&gt; The sending goroutine S continues running. The channel send operation is called a non-blocking operation</strong></p>
<ol start="2">
<li>Check receiving goroutine queue (empty), check buffer queue ( not full ), in which case the sending goroutine queue must be also empty, the value the sending goroutine S trying to send will be pushed into the value buffer queue.</li>
</ol>
<p><img src="../../images/channel%20golang/send2.png" alt="send value"></p>
<p><strong>-&gt; The sending goroutine S continues running. The channel send operation is called a non-blocking operation</strong></p>
<ol start="3">
<li>Check receiving goroutine queue (empty), check buffer queue ( full ), the sending goroutine S will be pushed into the sending goroutine queue of the channel and enter (and stay in) blocking state. It may be resumed to running state when another goroutine receives a value from the channel later.</li>
</ol>
<p><img src="../../images/channel%20golang/send3.png" alt="send value"></p>
<p><strong>-&gt; The sending goroutine S enter blocking. The channel send operation is called a blocking operation</strong></p>
<p>Once a non-nil channel is closed, sending a value to the channel will produce a runtime panic in the current goroutine. Note sending data to a closed channel is viewed as a non-blocking operation.</p>
<h3 id="channel-operation-try-to-close">Channel operation: try to close</h3>
<p>When a goroutine tries to close a not-closed non-nil channel, once the goroutine has acquired the lock of the channel, both of the following two steps will be performed by the following order.</p>
<ol>
<li>If the receiving goroutine queue of the channel is not empty, in which case the value buffer of the channel must be empty, all the goroutines in the receiving goroutine queue of the channel will be unshifted one by one, each of themm will receive a zero value of the elemenet type of the channel and be resumed to running state.</li>
</ol>
<p><img src="../../images/channel%20golang/close1.png" alt="send value"></p>
<ol start="2">
<li>If the sending goroutine queue of the channel is not empty, all the goroutines in the sending goroutine queue of the channel will be unshifted one by one and each of them will produce a panic for sending on a closed channel. This is the reason why we should avoid concurrent send and close operations on the same channel.</li>
</ol>
<p>After a channel is closed, the values which have been already pushed into the value buffer of the channel are still there.</p>
<p><strong>After a non-nil channel is closed, channel receive operations os the channel will never block</strong></p>
<h3 id="some-facts-about-the-internal-queues-of-a-channel">Some facts about the internal queues of a channel</h3>
<ul>
<li>If the channel is closed, both its sending and receiving goroutine queue must be empty, but its value buffer may not be empty.</li>
<li>At any time, if the value buffer is not empty, then its receiving goroutine queue must be empty.</li>
<li>At any time, if the value buffer is not full, then its sending goroutine queue must be empty.</li>
<li>If the channel is buffered, then at time, at least one of the channel&rsquo;s goroutine queues must be empty (sending, receiving or both).</li>
<li>If the channel is unbuffered, most of the time one of its sending goroutine queue and the receiving goroutine queue must be empty, with one exception. The exception is that a goroutine may be pushed into both of the two queues when execution a select control flow code block.</li>
</ul>
<p><strong>References</strong> <a href="https://go101.org/article/channel.html">Channel Use Case go101</a></p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Generator and Future Pattern</title>
      <link>https://idev-blog.web.app/posts/concurrency-pattern-generator-future/</link>
      <pubDate>Sat, 05 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/concurrency-pattern-generator-future/</guid>
      <description><![CDATA[<p>Generator Pattern allows the consumer of the data produced by the generator to run in parallel when the generator function is busy computing the next value.</p>
<p>A Future indicates any data that is needed in future but its computation can be started in parallel so that it can be fetched from the background when needed.</p>
<h2 id="generator">Generator</h2>
<p>Generator Pattern is used to generator a sequence of values which is used to produce some output. This allows the consumer of the data produced by the generator to run in parallel when the generator function is busy computing the text value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">fib</span>(n <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>	c <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">int</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// next state is depend on previous state
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">for</span> i, j <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span>; i &lt; n; i, j = i<span style="color:#ff79c6">+</span>j, i {
</span></span><span style="display:flex;"><span>			c <span style="color:#ff79c6">&lt;-</span> i
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">close</span>(c)
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> c
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">consumer</span>(c <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> v <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> c {
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(v)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The generator and the consumer can work concurrently (maybe in parallel) as the logic involved in both are different.</p>
<h2 id="future">Future</h2>
<p>A Future indicates any data that is needed in future but its computation can be started in parallel so that it can be fetched from the background when needed. Mostly, futures are used to send asynchronous http request.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> data <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    Body []<span style="color:#8be9fd">byte</span>
</span></span><span style="display:flex;"><span>    Error <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">futureDate</span>(url <span style="color:#8be9fd">string</span>) <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">chan</span> data {
</span></span><span style="display:flex;"><span>    c <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> data, <span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>(){
</span></span><span style="display:flex;"><span>        resp, err <span style="color:#ff79c6">:=</span> http.<span style="color:#50fa7b">Get</span>(url)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            c <span style="color:#ff79c6">&lt;-</span> data{
</span></span><span style="display:flex;"><span>            	Body:  <span style="color:#ff79c6">nil</span>,
</span></span><span style="display:flex;"><span>            	Error: err,
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        body, err <span style="color:#ff79c6">:=</span> ioutil.<span style="color:#50fa7b">ReadAll</span>(resp.Body)
</span></span><span style="display:flex;"><span>        resp.Body.<span style="color:#50fa7b">Close</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            c <span style="color:#ff79c6">&lt;-</span> data{
</span></span><span style="display:flex;"><span>            	Body:  <span style="color:#ff79c6">nil</span>,
</span></span><span style="display:flex;"><span>            	Error: err,
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        c <span style="color:#ff79c6">&lt;-</span> data{
</span></span><span style="display:flex;"><span>        	Body:  body,
</span></span><span style="display:flex;"><span>        	Error: err,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The actual http request is done asynchronously in a goroutine. The main function can continue doing other things. When the result is needed, we read the result from the channel. If the request isn&rsquo;t finished yet, the channel will block until the result is ready.</p>
<h2 id="different-between-generator-and-future">Different Between Generator and Future</h2>
<p>In generator pattern, we generate next state base on previous state (maybe not), but i purpose is compute many things in background. In future pattern, we use goroutine to execute an &ldquo;heavy job&rdquo; (only one job).</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Hai a Tr</title>
      <link>https://idev-blog.web.app/posts/poem-hai-%C4%91%E1%BB%A9a-tr%E1%BA%BB/</link>
      <pubDate>Thu, 13 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/poem-hai-%C4%91%E1%BB%A9a-tr%E1%BA%BB/</guid>
      <description><![CDATA[<p>Hai a tr ln ln ni rng ni</p>
<p>Xung quanh nh no l c, l cy</p>
<p>Hai a tr l ch l em, v l bn</p>
<p>Bn b xung quanh, him lm y m.</p>
<p></p>
<p>Hai a tr nhiu m kh ng</p>
<p>B m i ry mi cha v</p>
<p>Hai a tr ngi bn ngn nn sng</p>
<p>Ch bng trn tng, gi m xng con.</p>
<p></p>
<p>Hai a tr ri xa ni nng nu</p>
<p>B m lo chuyn hc hnh mai sau</p>
<p>Hai a tr l ch l em, khng l bn</p>
<p>Nhy dy, b mt, th v hn nhiu.</p>
<p></p>
<p>Hai a tr mai ny ri cng ln</p>
<p>a ri xm lng, a tm th </p>
<p>Hai a tr him no khi hi chuyn</p>
<p>Chuyn hc hnh, chuyn tng lai, chuyn mai sau</p>
<p>Hai a tr, hai a tr y khng cn&hellip;</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Ma</title>
      <link>https://idev-blog.web.app/posts/poem-m%C6%B0a/</link>
      <pubDate>Fri, 11 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/poem-m%C6%B0a/</guid>
      <description><![CDATA[<p>Ma,</p>
<p>Ma trn mi hin nh</p>
<p>n tn cnh ng xa</p>
<p>Ma,</p>
<p>Ma hoi, ma xi x</p>
<p>Ka ai ang th thuyn l</p>
<p>K c tri</p>
<p>Tri mi tn min xa.</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>La Hng</title>
      <link>https://idev-blog.web.app/posts/poem-l%E1%BB%ADa-h%E1%BB%93ng/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/poem-l%E1%BB%ADa-h%E1%BB%93ng/</guid>
      <description><![CDATA[<p>C mt m than nh</p>
<p>Thp ln ngn la hng</p>
<p>Dnh trn nhit huyt nng</p>
<p>Thp sng c m to.</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title></title>
      <link>https://idev-blog.web.app/posts/authentication-jwt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://idev-blog.web.app/posts/authentication-jwt/</guid>
      <description><![CDATA[<h1 id="authentication">Authentication</h1>
<h2 id="json-web-token">Json Web Token</h2>
<p>In its compact form, JSON Web Tokens consist of three parts separated by dots (.) which are:</p>
<ul>
<li>Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>
<p><strong>Header</strong>
The header typically consists of two parts: the type of the token, which is JWT, and the signing algorithm being used, such as HMAC SHA256 or RSA</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">&#34;alg&#34;</span>: <span style="color:#f1fa8c">&#34;HS256&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">&#34;typ&#34;</span>: <span style="color:#f1fa8c">&#34;JWT&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Then, this JSON is Base64Url encoded to form the first part of the JWT.</p>
<p><strong>Payload</strong></p>
<p>The second part of the token is the payload, which contains the claims. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims: registered, public, and private claims.</p>
<ul>
<li>Registered claims: There are a set of predefined claims which are not mandatory but recommended, to provide a set of useful
iss(issuer), exp(expiration time), sub(subject), aud(audience)</li>
<li>Public claims:</li>
<li>Private claims: These are the custom claims created to share information between parties that agree on using them and are neither registered or public claims.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">&#34;sub&#34;</span>: <span style="color:#f1fa8c">&#34;123456789&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">&#34;name&#34;</span>: <span style="color:#f1fa8c">&#34;John&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">&#34;admin&#34;</span>: <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The payload is then Base64Url encoded to form the second part of the JSON Web Token.</p>
<p><strong>Signature</strong></p>
<p>To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.
The signature is used to verify the message wasn&rsquo;t changed along the way, and, in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is.</p>
<p><strong>How do JSON Web Tokens work?</strong></p>
<p>In authentication, when the user successfully logs in using their credentials, a JSON Web Token will be returned. Since tokens are credentials,, greate care must be taken to prevent security issues. In general, you should not keep tokens longer than required.</p>
<p>You also should not store sensitive session data in browser storage due to lack of security.</p>
<p>Whenever the user wants to access a protected route or resource, the user agent should send the JWT, typically in the Authorization header using the Bearer schema.</p>
<p>The content os the header should look like the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>Authorization: Bearer &lt;token&gt;
</span></span></code></pre></div>]]></description>
      
    </item>
    
    
    
    
    
    
  </channel>
</rss>
