<!DOCTYPE html>
<html class="" lang="en-us"><head>
    
    <meta name="viewport" content="width=device-width" />
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=7" />

    <link
    rel="icon"
    href='/favicon.png'
/>
<link
    rel="shortcut icon"
    href='/favicon.ico'
    type="image/x-icon"
/>
<link
    rel="apple-touch-icon"
    href='/apple-touch-icon.png'
/>

    <link
        rel="icon"
        href='/logo.svg'
        type="image/svg+xml"
    />

<title>
        
            Channel Use Case in Golang  &ndash;
        
        Dev&#39;s Log
    </title>
    <link href="/symbols-nerd-font/symbols-nerd-font.css" rel="stylesheet" />
    <link href="/jetbrains-mono/jetbrains-mono.css" rel="stylesheet" />
    
    
    <link type="text/css" rel="stylesheet" href=https://idev-blog.web.app/css/styles.9b53275cb4d8eaa20bdbb49c202ffdc504a19d2a26a8724d44e3ab30e790bf408f9945c440b56636adeb6aac088b0ce94240f32a3e22b4dd1c55f8bb05663c0a.css integrity="sha512-m1MnXLTY6qIL27ScIC/9xQShnSomqHJNROOrMOeQv0CPmUXEQLVmNq3raqwIiwzpQkDzKj4itN0cVfi7BWY8Cg==" />
<meta name="author" content="" />

    
        <meta name="keywords" content='basic, golang' />
    
    
        <meta name="description" content="ow many channel use cases
Asynchronous and concurrency programing with Go channels is easy and enjoyable. The channel synchronization technique has wider range of uses and have more variables than the synchronization solutions used in some other languages, such as the actor model and the async/await pattern." />
    

<meta property="og:site_name"
    content='Dev&#39;s Log' />

    <meta property="og:title" content="Channel Use Case in Golang" />
    <meta property="og:type" content="article" />
    
    <meta
        property="article:author" content="" />
    <meta
        property="article:published_time"
        content='2022-11-22T00:00:00Z&#43;0000' />
    
        
            <meta property="article:tag" content="basic" />
        
            <meta property="article:tag" content="golang" />
        
    
    <meta property="og:url" content="https://idev-blog.web.app/posts/programming-language-channel-usecase/" />
    
    
    <meta property="og:image"
        content="https://idev-blog.web.app/android-chrome-512x512.png" />
    
        <meta property="og:description" content="This article will show many channel use cases
Asynchronous and concurrency programing with Go channels is easy and enjoyable. The channel synchronization techni" />
    

<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:domain"
      content='idev-blog.web.a'
/>
<meta property="twitter:url" content="https://idev-blog.web.app/posts/programming-language-channel-usecase/" />


    <meta name="twitter:title" content="Channel Use Case in Golang" />
    
    
    
    <meta name="twitter:image"
        content="https://idev-blog.web.app/android-chrome-512x512.png" />
    
        <meta name="twitter:description" content="This article will show many channel use cases
Asynchronous and concurrency programing with Go channels is easy and enjoyable. The channel synchronization techni" />
    

<link rel="manifest" href="/manifest/index.json" />
</head>


<body>
        <div id="baseContainer"><header class="">
<div class="titleAndSearchContainer">
        <div id="titleContainer">
            
                <a class="unstyledLink" href="/">
                    <img src='/logo.png' alt='Logo'/>
                </a>
            
            <div class="rightOfLogo">
                <div class="titleAndHamburger">
                    <h1>
                        <a class="unstyledLink" href="/">Dev&#39;s Log</a>
                        
                    </h1>
                    
                </div>
                <div id="wide_nav"><nav>
    
    <ul id="main-nav">
        <li><a href="/">Home</a></li>
        
            <li><a href="/posts">Posts</a></li>
        
        
        
        
        
        
        
            <li><a href="/authors">Authors</a></li>
        
        
            <li><a href="/series">Series</a></li>
        
        
            <li><a href="/tags">Tags</a></li>
        
        
    </ul>
</nav>
</div>
            </div>
        </div>
        <div class="search">
    <input id="searchbar" type="text" placeholder='Search' />
    <a class="nerdlink" onclick="newSearch();">&#xf002;</a>
</div>
<script>
    function newSearch() {
        let term = searchbar.value.trim();
        if (!term) return;
        location.href = `/search?q=${term}`;
    }
    searchbar.onkeyup = (ev) => {if (ev.keyCode == 13) newSearch()};
</script>

    </div>
    <div id="links">
        <a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="/index.xml">
    
    
        &#xf09e;
    
    <span>
        RSS
    </span>
</a>

        
        <a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="https://www.facebook.com/ngoctd314">
    
    
        &#xf09a;
    
    <span>
        Facebook
    </span>
</a>
<a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="https://github.com/ngoctd314">
    
    
        &#xf09b;
    
    <span>
        GitHub
    </span>
</a>
<a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="https://github.com/ngoctd314">
    
    
        &#xf0e1;
    
    <span>
        Email
    </span>
</a>

    </div>
    
        <div id="sidebar_nav"><nav>
    
    <ul id="main-nav">
        <li><a href="/">Home</a></li>
        
            <li><a href="/posts">Posts</a></li>
        
        
        
        
        
        
        
            <li><a href="/authors">Authors</a></li>
        
        
            <li><a href="/series">Series</a></li>
        
        
            <li><a href="/tags">Tags</a></li>
        
        
    </ul>
</nav>
</div>
        
    

</header>
<div id="contentContainer">
                <div id="content">
                    <main>
<article class="card single">
    
        <h1>Channel Use Case in Golang</h1>
    


    
        <p class="date">
            <span title='Date'> </span>
    2022-11-22


                <span>/ authors </span>
                
                
                    <a
                        
                        href="/authors/ngoctd">#ngoctd</a>
                
            
            
                <span>/ tags </span>
                
                    <a
                        
                        href="/tags/basic">#basic</a>
                
                    <a
                        
                        href="/tags/golang">#golang</a>
                
            
        </p>
    
    
    
    
    <div><p>This article will show many channel use cases</p>
<ul>
<li>Asynchronous and concurrency programing with Go channels is easy and enjoyable.</li>
<li>The channel synchronization technique has wider range of uses and have more variables than the synchronization solutions used in some other languages, such as the actor model and the async/await pattern.</li>
</ul>
<h2 id="use-channels-as-futurespromises">Use Channels as Futures/Promises</h2>
<p><strong>Return receive-only channels as results</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">longTimeRequest</span>() <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{} {
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// simulate workload run 3s in using goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		time.<span style="color:#50fa7b">Sleep</span>(time.Second <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">3</span>)
</span></span><span style="display:flex;"><span>		ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// return immediately
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> ch
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ch1 <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">longTimeRequest</span>()
</span></span><span style="display:flex;"><span>	ch2 <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">longTimeRequest</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	_, _ = <span style="color:#ff79c6">&lt;-</span>ch1, <span style="color:#ff79c6">&lt;-</span>ch2 <span style="color:#6272a4">// get result in future
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;exec in: &#34;</span>, time.<span style="color:#50fa7b">Since</span>(now)) <span style="color:#6272a4">// ~ 3s
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><p><strong>Pass send-only channels as arguments</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">longTimeRequest</span>(ch <span style="color:#8be9fd;font-style:italic">chan</span><span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// simulate workload run 3s in using goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;send value to channel&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// buffer = 2 to avoid block to handle channle receive
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}, <span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">longTimeRequest</span>(ch)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">longTimeRequest</span>(ch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span>ch
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span>ch
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;exec in: &#34;</span>, time.<span style="color:#50fa7b">Since</span>(now))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>The first response win</strong></p>
<p>Sometimes, a piece of data can be received from several sources to avoid high latencies. For a lot of factors, the response durations of these sources may vary much. To make the response duration as short as possible, we can send a request to every source in separated goroutine. Only the first response use case will be used, other slower ones will be discarded.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">source</span>(c <span style="color:#8be9fd;font-style:italic">chan</span><span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>	c <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// c must be a buffered channel
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// If there are N sources, the capacity of the communication channel must be at least N-1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// to avoid the goroutines corresponding the discarded responses being blocked for ever
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	c <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}, <span style="color:#bd93f9">5</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; <span style="color:#8be9fd;font-style:italic">cap</span>(c); i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">source</span>(c)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// first response win
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">&lt;-</span>c
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="use-channels-for-notifications">Use Channels for Notifications</h2>
<p>Notifications can be viewed as special requests/responses in which the responded values are not important. Generally, we use the blank type struct{} as the element types of the notification channels.</p>
<p><strong>1-to-1 notification by sending a value to a channel</strong></p>
<p>If there are no values to be received from a channel, then the next receive operation on the channel will block until another goroutine sends a value to the channel. So we can send a value to a channel to notify another goroutine which is waiting to receive a value from the same channel.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">blocking</span>(c <span style="color:#8be9fd;font-style:italic">chan</span><span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>	time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// unlock by notifycation
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	c <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">blocking</span>(ch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// blocking
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">&lt;-</span>ch
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;since: &#34;</span>, time.<span style="color:#50fa7b">Since</span>(now))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> os.Signal)
</span></span><span style="display:flex;"><span>	signal.<span style="color:#50fa7b">Notify</span>(sig, os.Interrupt)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span>sig
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>1-to-1 notification by receiving a value from a channel</strong></p>
<p>If the value buffer queue of a channel is full (the buffer queue of an unbuffered channel is always full), a send operation on the channel will block until another goroutine receives a value from the channel. So we can receive a value from a channel to notify another goroutine which is waiting to send a value to the same channel.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">blocking</span>(c <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>	time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// unblock the second send in main goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">&lt;-</span>c
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">blocking</span>(ch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// blocked here, wait for a notification
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;since: &#34;</span>, time.<span style="color:#50fa7b">Since</span>(now))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> os.Signal)
</span></span><span style="display:flex;"><span>	signal.<span style="color:#50fa7b">Notify</span>(sig, os.Interrupt)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span>sig
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>N-to-1 and 1-to-N notifications</strong></p>
<p>Broadcast (1-to-N) notifications by closing a channel</p>
</div>
</article>


    
    
        
        
        
            
                
                
        
            
                
                
        
    





    
    
        
        <div class="relatedArticlesContainer">
            <hr />
            <h2>More posts like this</h2>
            <div class="postlist ">
                <article class="card postlistitem">
    <div>
        <h2>
            <a href="https://idev-blog.web.app/posts/concurrency-pattern-pipeline-and-cancellation/">Pipelines and cancellation</a>
        </h2>
        <p class="date">
            <span title='Date'> </span>
    2022-11-26


                | 
                <span title='Tags'> </span>
                
                    <a href="/tags/concurrency-pattern">#concurrency pattern</a>
                
                    <a href="/tags/golang">#golang</a>
                
            
        </p>
        
            
        
        
            <div class="articlePreview">
                <p>
                    
                        Go&rsquo;s concurrency primitives make it easy to construct streaming data pipelines that make efficient use of I/O and multiple CPUs. This article introduces what is pipeline, how to to construct a pipeline and introduces techniques for dealing with failures cleanly.
                    
                </p>
                
            </div>
        
    </div>
</article>
<article class="card postlistitem">
    <div>
        <h2>
            <a href="https://idev-blog.web.app/posts/programming-language-channel-in-golang/">Channel in Golang</a>
        </h2>
        <p class="date">
            <span title='Date'> </span>
    2022-11-05


                | 
                <span title='Tags'> </span>
                
                    <a href="/tags/basic">#basic</a>
                
                    <a href="/tags/golang">#golang</a>
                
            
        </p>
        
            
        
        
            <div class="articlePreview">
                <p>
                    
                        Channel is an important built-in feature in Go. It is one of the features makes Go unique. Channel makes concurrent programming convenient, fun and lowers the difficulties of concurrent programming. Channel mainly acts as a concurrency synchronization technique. To understand channels better, the internal structure of channels and some implementation details by the standard Go compiler/runtime are also simply described.
                    
                </p>
                
            </div>
        
    </div>
</article>

            </div>
        </div>
    


                    </main><footer>

<p><small>
        2022 &copy; Tran Duc Ngoc
    </small></p>
    <p><small>
        
    </small></p>
</footer>
</div>
            </div>
        </div>


</body>
</html>
