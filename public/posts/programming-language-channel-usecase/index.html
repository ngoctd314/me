<!DOCTYPE html>
<html class="" lang="en-us"><head>
    
    <meta name="viewport" content="width=device-width" />
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=7" />

    <link
    rel="icon"
    href='/favicon.png'
/>
<link
    rel="shortcut icon"
    href='/favicon.ico'
    type="image/x-icon"
/>
<link
    rel="apple-touch-icon"
    href='/apple-touch-icon.png'
/>

    <link
        rel="icon"
        href='/logo.svg'
        type="image/svg+xml"
    />

<title>
        
            Channel Use Case in Golang  &ndash;
        
        Dev&#39;s Log
    </title>
    <link href="/symbols-nerd-font/symbols-nerd-font.css" rel="stylesheet" />
    <link href="/jetbrains-mono/jetbrains-mono.css" rel="stylesheet" />
    
    
    <link type="text/css" rel="stylesheet" href=https://idev-blog.web.app/css/styles.9b53275cb4d8eaa20bdbb49c202ffdc504a19d2a26a8724d44e3ab30e790bf408f9945c440b56636adeb6aac088b0ce94240f32a3e22b4dd1c55f8bb05663c0a.css integrity="sha512-m1MnXLTY6qIL27ScIC/9xQShnSomqHJNROOrMOeQv0CPmUXEQLVmNq3raqwIiwzpQkDzKj4itN0cVfi7BWY8Cg==" />
<meta name="author" content="" />

    
        <meta name="keywords" content='basic, golang' />
    
    
        <meta name="description" content="ow many channel use cases
Asynchronous and concurrency programing with Go channels is easy and enjoyable. The channel synchronization technique has wider range of uses and have more variables than the synchronization solutions used in some other languages, such as the actor model and the async/await pattern." />
    

<meta property="og:site_name"
    content='Dev&#39;s Log' />

    <meta property="og:title" content="Channel Use Case in Golang" />
    <meta property="og:type" content="article" />
    
    <meta
        property="article:author" content="" />
    <meta
        property="article:published_time"
        content='2022-12-27T00:00:00Z&#43;0000' />
    
        
            <meta property="article:tag" content="basic" />
        
            <meta property="article:tag" content="golang" />
        
    
    <meta property="og:url" content="https://idev-blog.web.app/posts/programming-language-channel-usecase/" />
    
    
    <meta property="og:image"
        content="https://idev-blog.web.app/android-chrome-512x512.png" />
    
        <meta property="og:description" content="This article will show many channel use cases
Asynchronous and concurrency programing with Go channels is easy and enjoyable. The channel synchronization techni" />
    

<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:domain"
      content='idev-blog.web.a'
/>
<meta property="twitter:url" content="https://idev-blog.web.app/posts/programming-language-channel-usecase/" />


    <meta name="twitter:title" content="Channel Use Case in Golang" />
    
    
    
    <meta name="twitter:image"
        content="https://idev-blog.web.app/android-chrome-512x512.png" />
    
        <meta name="twitter:description" content="This article will show many channel use cases
Asynchronous and concurrency programing with Go channels is easy and enjoyable. The channel synchronization techni" />
    

<link rel="manifest" href="/manifest/index.json" />
</head>


<body>
        <div id="baseContainer"><header class="">
<div class="titleAndSearchContainer">
        <div id="titleContainer">
            
                <a class="unstyledLink" href="/">
                    <img src='/logo.png' alt='Logo'/>
                </a>
            
            <div class="rightOfLogo">
                <div class="titleAndHamburger">
                    <h1>
                        <a class="unstyledLink" href="/">Dev&#39;s Log</a>
                        
                    </h1>
                    
                </div>
                <div id="wide_nav"><nav>
    
    <ul id="main-nav">
        <li><a href="/">Home</a></li>
        
            <li><a href="/posts">Posts</a></li>
        
        
        
        
        
        
        
            <li><a href="/authors">Authors</a></li>
        
        
            <li><a href="/series">Series</a></li>
        
        
            <li><a href="/tags">Tags</a></li>
        
        
    </ul>
</nav>
</div>
            </div>
        </div>
        <div class="search">
    <input id="searchbar" type="text" placeholder='Search' />
    <a class="nerdlink" onclick="newSearch();">&#xf002;</a>
</div>
<script>
    function newSearch() {
        let term = searchbar.value.trim();
        if (!term) return;
        location.href = `/search?q=${term}`;
    }
    searchbar.onkeyup = (ev) => {if (ev.keyCode == 13) newSearch()};
</script>

    </div>
    <div id="links">
        <a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="/index.xml">
    
    
        &#xf09e;
    
    <span>
        RSS
    </span>
</a>

        
        <a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="https://www.facebook.com/ngoctd314">
    
    
        &#xf09a;
    
    <span>
        Facebook
    </span>
</a>
<a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="https://github.com/ngoctd314">
    
    
        &#xf09b;
    
    <span>
        GitHub
    </span>
</a>
<a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="https://github.com/ngoctd314">
    
    
        &#xf0e1;
    
    <span>
        Email
    </span>
</a>

    </div>
    
        <div id="sidebar_nav"><nav>
    
    <ul id="main-nav">
        <li><a href="/">Home</a></li>
        
            <li><a href="/posts">Posts</a></li>
        
        
        
        
        
        
        
            <li><a href="/authors">Authors</a></li>
        
        
            <li><a href="/series">Series</a></li>
        
        
            <li><a href="/tags">Tags</a></li>
        
        
    </ul>
</nav>
</div>
        
    

</header>
<div id="contentContainer">
                <div id="content">
                    <main>
<article class="card single">
    
        <h1>Channel Use Case in Golang</h1>
    


    
        <p class="date">
            <span title='Date'>ï—¬ </span>
    2022-12-27


                <span>/ authors </span>
                
                
                    <a
                        
                        href="/authors/ngoctd">#ngoctd</a>
                
            
            
                <span>/ tags </span>
                
                    <a
                        
                        href="/tags/basic">#basic</a>
                
                    <a
                        
                        href="/tags/golang">#golang</a>
                
            
        </p>
    
    
    
    
    <div><p>This article will show many channel use cases</p>
<ul>
<li>Asynchronous and concurrency programing with Go channels is easy and enjoyable.</li>
<li>The channel synchronization technique has wider range of uses and have more variables than the synchronization solutions used in some other languages, such as the actor model and the async/await pattern.</li>
</ul>
<h2 id="use-channels-as-futurespromises">Use Channels as Futures/Promises</h2>
<p><strong>Return receive-only channels as results</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">longTimeRequest</span>() <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{} {
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// simulate workload run 3s in using goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		time.<span style="color:#50fa7b">Sleep</span>(time.Second <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">3</span>)
</span></span><span style="display:flex;"><span>		ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// return immediately
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> ch
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ch1 <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">longTimeRequest</span>()
</span></span><span style="display:flex;"><span>	ch2 <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">longTimeRequest</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	_, _ = <span style="color:#ff79c6">&lt;-</span>ch1, <span style="color:#ff79c6">&lt;-</span>ch2 <span style="color:#6272a4">// get result in future
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;exec in: &#34;</span>, time.<span style="color:#50fa7b">Since</span>(now)) <span style="color:#6272a4">// ~ 3s
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><p><strong>Pass send-only channels as arguments</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">longTimeRequest</span>(ch <span style="color:#8be9fd;font-style:italic">chan</span><span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// simulate workload run 3s in using goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;send value to channel&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// buffer = 2 to avoid block to handle channle receive
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}, <span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">longTimeRequest</span>(ch)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">longTimeRequest</span>(ch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span>ch
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span>ch
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;exec in: &#34;</span>, time.<span style="color:#50fa7b">Since</span>(now))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>The first response win</strong></p>
<p>Sometimes, a piece of data can be received from several sources to avoid high latencies. For a lot of factors, the response durations of these sources may vary much. To make the response duration as short as possible, we can send a request to every source in separated goroutine. Only the first response use case will be used, other slower ones will be discarded.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">source</span>(c <span style="color:#8be9fd;font-style:italic">chan</span><span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>	c <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// c must be a buffered channel
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// If there are N sources, the capacity of the communication channel must be at least N-1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// to avoid the goroutines corresponding the discarded responses being blocked for ever
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	c <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}, <span style="color:#bd93f9">5</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; <span style="color:#8be9fd;font-style:italic">cap</span>(c); i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">source</span>(c)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// first response win
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">&lt;-</span>c
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="use-channels-for-notifications">Use Channels for Notifications</h2>
<p>Notifications can be viewed as special requests/responses in which the responded values are not important. Generally, we use the blank type struct{} as the element types of the notification channels.</p>
<p><strong>1-to-1 notification by sending a value to a channel</strong></p>
<p>If there are no values to be received from a channel, then the next receive operation on the channel will block until another goroutine sends a value to the channel. So we can send a value to a channel to notify another goroutine which is waiting to receive a value from the same channel.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">blocking</span>(c <span style="color:#8be9fd;font-style:italic">chan</span><span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>	time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// unlock by notifycation
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	c <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">blocking</span>(ch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// blocking
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">&lt;-</span>ch
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;since: &#34;</span>, time.<span style="color:#50fa7b">Since</span>(now))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> os.Signal)
</span></span><span style="display:flex;"><span>	signal.<span style="color:#50fa7b">Notify</span>(sig, os.Interrupt)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span>sig
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>1-to-1 notification by receiving a value from a channel</strong></p>
<p>If the value buffer queue of a channel is full (the buffer queue of an unbuffered channel is always full), a send operation on the channel will block until another goroutine receives a value from the channel. So we can receive a value from a channel to notify another goroutine which is waiting to send a value to the same channel.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">blocking</span>(c <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>	time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// unblock the second send in main goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">&lt;-</span>c
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">blocking</span>(ch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// blocked here, wait for a notification
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;since: &#34;</span>, time.<span style="color:#50fa7b">Since</span>(now))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> os.Signal)
</span></span><span style="display:flex;"><span>	signal.<span style="color:#50fa7b">Notify</span>(sig, os.Interrupt)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span>sig
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>N-to-1 and 1-to-N notifications</strong></p>
<p>By making using of the feature that infinite values can be received from a closed channel, we can close a channel to broadcast notifications (1-to-N 1 main to N worker). Use sync.WaitGroup for N-to-1(N worker to 1 main) notification</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">worker</span>(ready <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}, wg <span style="color:#ff79c6">*</span>sync.WaitGroup) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> wg.<span style="color:#50fa7b">Done</span>() <span style="color:#6272a4">// N-to-1 notification
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">&lt;-</span>ready         <span style="color:#6272a4">// block here and wait notification
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	time.<span style="color:#50fa7b">Sleep</span>(time.Second)
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;run&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	ready <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>	wg <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>sync.WaitGroup{}
</span></span><span style="display:flex;"><span>	wg.<span style="color:#50fa7b">Add</span>(<span style="color:#bd93f9">3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">worker</span>(ready, wg)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">worker</span>(ready, wg)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">worker</span>(ready, wg)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">close</span>(ready)
</span></span><span style="display:flex;"><span>	wg.<span style="color:#50fa7b">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Timer: Scheduled notification</strong></p>
<p>A custom one-time timer notification</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">after</span>(duration time.Duration) <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{} {
</span></span><span style="display:flex;"><span>	ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>		time.<span style="color:#50fa7b">Sleep</span>(duration)
</span></span><span style="display:flex;"><span>		ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> ch
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	now <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">&lt;-</span><span style="color:#50fa7b">after</span>(time.Second)
</span></span><span style="display:flex;"><span>	fmt.<span style="color:#50fa7b">Println</span>(time.<span style="color:#50fa7b">Since</span>(now))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="use-channels-as-mutex-locks">Use Channels as Mutex Locks</h2>
<p>There are two manners to use one-capacity buffered channels as mutex locks</p>
<ol>
<li>Lock through a send, unlock through a receive</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	cnt <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>	wg <span style="color:#ff79c6">:=</span> sync.WaitGroup{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	lock <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}, <span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> increase = <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">defer</span> wg.<span style="color:#50fa7b">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// lock through send
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		lock <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>		cnt<span style="color:#ff79c6">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// unlock
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">&lt;-</span>lock
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; <span style="color:#bd93f9">10000</span>; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>		wg.<span style="color:#50fa7b">Add</span>(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">increase</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	wg.<span style="color:#50fa7b">Wait</span>()
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(cnt)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li>Lock through a receive, unlock through a send</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	cnt <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>	wg <span style="color:#ff79c6">:=</span> sync.WaitGroup{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	lock <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}, <span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>	lock <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> increase = <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">defer</span> wg.<span style="color:#50fa7b">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// lock through receive
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">&lt;-</span>lock
</span></span><span style="display:flex;"><span>		cnt<span style="color:#ff79c6">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// unlock
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		lock <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; <span style="color:#bd93f9">10000</span>; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>		wg.<span style="color:#50fa7b">Add</span>(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">increase</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	wg.<span style="color:#50fa7b">Wait</span>()
</span></span><span style="display:flex;"><span>	log.<span style="color:#50fa7b">Println</span>(cnt)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="use-channels-as-counting-semaphores">Use Channels as Counting Semaphores</h2>
<p>Buffered channels can be used as counting semaphores
Counting semaphores can be viewed as multi-owner locks. If the capacity of a channel is N, then it can be viewed as a lock which can have most N owners at any time.</p>
<p>Counting semaphores are often used to enforce a maximum number of concurrent requests.</p>
<p>There are two manners to acquire one piece of ownership of a channel semaphore</p>
<ol>
<li>Acquire ownership through a send, release through a receive</li>
<li>Acquire ownership through a receive, release through a send</li>
</ol>
</div>
</article>


    
    
        
        
        
            
                
                
        
            
                
                
        
    





    
    
        
        <div class="relatedArticlesContainer">
            <hr />
            <h2>More posts like this</h2>
            <div class="postlist ">
                <article class="card postlistitem">
    <div>
        <h2>
            <a href="https://idev-blog.web.app/posts/programming-language-wire-for-d/">wire for D. D for Dependency Injection</a>
        </h2>
        <p class="date">
            <span title='Date'>ï—¬ </span>
    2022-12-12


                | 
                <span title='Tags'>ï€« </span>
                
                    <a href="/tags/basic">#basic</a>
                
                    <a href="/tags/golang">#golang</a>
                
                    <a href="/tags/solid">#solid</a>
                
            
        </p>
        
            
        
        
            <div class="articlePreview">
                <p>
                    
                        Wire has two core concepts: providers and injectors.
Providers The primary mechanism in Wire is the providers: a function that can produce a value.
type Foo struct { X int } func ProvideFoo() Foo { return Foo{X: 42} } Providers can also return errors
                    
                </p>
                
            </div>
        
    </div>
</article>
<article class="card postlistitem">
    <div>
        <h2>
            <a href="https://idev-blog.web.app/posts/concurrency-pattern-pipeline-and-cancellation/">Pipelines and cancellation</a>
        </h2>
        <p class="date">
            <span title='Date'>ï—¬ </span>
    2022-11-26


                | 
                <span title='Tags'>ï€« </span>
                
                    <a href="/tags/concurrency-pattern">#concurrency pattern</a>
                
                    <a href="/tags/golang">#golang</a>
                
            
        </p>
        
            
        
        
            <div class="articlePreview">
                <p>
                    
                        Go&rsquo;s concurrency primitives make it easy to construct streaming data pipelines that make efficient use of I/O and multiple CPUs. This article introduces what is pipeline, how to to construct a pipeline and introduces techniques for dealing with failures cleanly.
                    
                </p>
                
            </div>
        
    </div>
</article>

            </div>
        </div>
    


                    </main><footer>

<p><small>
        2023 &copy; Tran Duc Ngoc
    </small></p>
    <p><small>
        
    </small></p>
</footer>
</div>
            </div>
        </div>


</body>
</html>
